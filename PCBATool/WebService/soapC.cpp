/* soapC.cpp
   Generated by gSOAP 2.8.31 for WebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.31 2016-05-07 11:08:37 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__CheckTimeGap:
		return soap_in_PointerTo_ns1__CheckTimeGap(soap, NULL, NULL, "ns1:CheckTimeGap");
	case SOAP_TYPE_PointerTo_ns1__Ispasspostburnin:
		return soap_in_PointerTo_ns1__Ispasspostburnin(soap, NULL, NULL, "ns1:Ispasspostburnin");
	case SOAP_TYPE_PointerTo_ns1__checkingSNNextRoute:
		return soap_in_PointerTo_ns1__checkingSNNextRoute(soap, NULL, NULL, "ns1:checkingSNNextRoute");
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData:
		return soap_in_PointerTo_ns1__blakeTestExchangeData(soap, NULL, NULL, "ns1:blakeTestExchangeData");
	case SOAP_TYPE_PointerTo_ns1__goNewRouteseq:
		return soap_in_PointerTo_ns1__goNewRouteseq(soap, NULL, NULL, "ns1:goNewRouteseq");
	case SOAP_TYPE_PointerTo_ns1__fetchSnCurrentLocation:
		return soap_in_PointerTo_ns1__fetchSnCurrentLocation(soap, NULL, NULL, "ns1:fetchSnCurrentLocation");
	case SOAP_TYPE_PointerTo_ns1__getMaintanceParm:
		return soap_in_PointerTo_ns1__getMaintanceParm(soap, NULL, NULL, "ns1:getMaintanceParm");
	case SOAP_TYPE_PointerTo_ns1__checkMac:
		return soap_in_PointerTo_ns1__checkMac(soap, NULL, NULL, "ns1:checkMac");
	case SOAP_TYPE_PointerTo_ns1__InsertTimeControl:
		return soap_in_PointerTo_ns1__InsertTimeControl(soap, NULL, NULL, "ns1:InsertTimeControl");
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData1:
		return soap_in_PointerTo_ns1__blakeTestExchangeData1(soap, NULL, NULL, "ns1:blakeTestExchangeData1");
	case SOAP_TYPE_PointerTo_ns1__InsertPRateData:
		return soap_in_PointerTo_ns1__InsertPRateData(soap, NULL, NULL, "ns1:InsertPRateData");
	case SOAP_TYPE_PointerTo_ns1__getAssemblyData:
		return soap_in_PointerTo_ns1__getAssemblyData(soap, NULL, NULL, "ns1:getAssemblyData");
	case SOAP_TYPE_PointerTo_ns1__staffCheck:
		return soap_in_PointerTo_ns1__staffCheck(soap, NULL, NULL, "ns1:staffCheck");
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess_USCOREA:
		return soap_in_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, NULL, NULL, "ns1:SnSaveTechProcess_A");
	case SOAP_TYPE_PointerTo_ns1__checkSNPangusOrderNo:
		return soap_in_PointerTo_ns1__checkSNPangusOrderNo(soap, NULL, NULL, "ns1:checkSNPangusOrderNo");
	case SOAP_TYPE_PointerTo_ns1__checkSNOrderNo:
		return soap_in_PointerTo_ns1__checkSNOrderNo(soap, NULL, NULL, "ns1:checkSNOrderNo");
	case SOAP_TYPE_PointerTo_ns1__loadNgPanelNo:
		return soap_in_PointerTo_ns1__loadNgPanelNo(soap, NULL, NULL, "ns1:loadNgPanelNo");
	case SOAP_TYPE_PointerTo_ns1__loadTimeControlData:
		return soap_in_PointerTo_ns1__loadTimeControlData(soap, NULL, NULL, "ns1:loadTimeControlData");
	case SOAP_TYPE_PointerTo_ns1__bindAssembly:
		return soap_in_PointerTo_ns1__bindAssembly(soap, NULL, NULL, "ns1:bindAssembly");
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess:
		return soap_in_PointerTo_ns1__SnSaveTechProcess(soap, NULL, NULL, "ns1:SnSaveTechProcess");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CheckTimeGapResponse"))
		{	*type = SOAP_TYPE__ns1__CheckTimeGapResponse;
			return soap_in__ns1__CheckTimeGapResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckTimeGap"))
		{	*type = SOAP_TYPE__ns1__CheckTimeGap;
			return soap_in__ns1__CheckTimeGap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IspasspostburninResponse"))
		{	*type = SOAP_TYPE__ns1__IspasspostburninResponse;
			return soap_in__ns1__IspasspostburninResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Ispasspostburnin"))
		{	*type = SOAP_TYPE__ns1__Ispasspostburnin;
			return soap_in__ns1__Ispasspostburnin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkingSNNextRouteResponse"))
		{	*type = SOAP_TYPE__ns1__checkingSNNextRouteResponse;
			return soap_in__ns1__checkingSNNextRouteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkingSNNextRoute"))
		{	*type = SOAP_TYPE__ns1__checkingSNNextRoute;
			return soap_in__ns1__checkingSNNextRoute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blakeTestExchangeDataResponse"))
		{	*type = SOAP_TYPE__ns1__blakeTestExchangeDataResponse;
			return soap_in__ns1__blakeTestExchangeDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blakeTestExchangeData"))
		{	*type = SOAP_TYPE__ns1__blakeTestExchangeData;
			return soap_in__ns1__blakeTestExchangeData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:goNewRouteseqResponse"))
		{	*type = SOAP_TYPE__ns1__goNewRouteseqResponse;
			return soap_in__ns1__goNewRouteseqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:goNewRouteseq"))
		{	*type = SOAP_TYPE__ns1__goNewRouteseq;
			return soap_in__ns1__goNewRouteseq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchSnCurrentLocationResponse"))
		{	*type = SOAP_TYPE__ns1__fetchSnCurrentLocationResponse;
			return soap_in__ns1__fetchSnCurrentLocationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchSnCurrentLocation"))
		{	*type = SOAP_TYPE__ns1__fetchSnCurrentLocation;
			return soap_in__ns1__fetchSnCurrentLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMaintanceParmResponse"))
		{	*type = SOAP_TYPE__ns1__getMaintanceParmResponse;
			return soap_in__ns1__getMaintanceParmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMaintanceParm"))
		{	*type = SOAP_TYPE__ns1__getMaintanceParm;
			return soap_in__ns1__getMaintanceParm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkMacResponse"))
		{	*type = SOAP_TYPE__ns1__checkMacResponse;
			return soap_in__ns1__checkMacResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkMac"))
		{	*type = SOAP_TYPE__ns1__checkMac;
			return soap_in__ns1__checkMac(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertTimeControlResponse"))
		{	*type = SOAP_TYPE__ns1__InsertTimeControlResponse;
			return soap_in__ns1__InsertTimeControlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertTimeControl"))
		{	*type = SOAP_TYPE__ns1__InsertTimeControl;
			return soap_in__ns1__InsertTimeControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blakeTestExchangeData1Response"))
		{	*type = SOAP_TYPE__ns1__blakeTestExchangeData1Response;
			return soap_in__ns1__blakeTestExchangeData1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:blakeTestExchangeData1"))
		{	*type = SOAP_TYPE__ns1__blakeTestExchangeData1;
			return soap_in__ns1__blakeTestExchangeData1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertPRateDataResponse"))
		{	*type = SOAP_TYPE__ns1__InsertPRateDataResponse;
			return soap_in__ns1__InsertPRateDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertPRateData"))
		{	*type = SOAP_TYPE__ns1__InsertPRateData;
			return soap_in__ns1__InsertPRateData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAssemblyDataResponse"))
		{	*type = SOAP_TYPE__ns1__getAssemblyDataResponse;
			return soap_in__ns1__getAssemblyDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAssemblyData"))
		{	*type = SOAP_TYPE__ns1__getAssemblyData;
			return soap_in__ns1__getAssemblyData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:staffCheckResponse"))
		{	*type = SOAP_TYPE__ns1__staffCheckResponse;
			return soap_in__ns1__staffCheckResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:staffCheck"))
		{	*type = SOAP_TYPE__ns1__staffCheck;
			return soap_in__ns1__staffCheck(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnSaveTechProcess_AResponse"))
		{	*type = SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse;
			return soap_in__ns1__SnSaveTechProcess_USCOREAResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnSaveTechProcess_A"))
		{	*type = SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA;
			return soap_in__ns1__SnSaveTechProcess_USCOREA(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSNPangusOrderNoResponse"))
		{	*type = SOAP_TYPE__ns1__checkSNPangusOrderNoResponse;
			return soap_in__ns1__checkSNPangusOrderNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSNPangusOrderNo"))
		{	*type = SOAP_TYPE__ns1__checkSNPangusOrderNo;
			return soap_in__ns1__checkSNPangusOrderNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSNOrderNoResponse"))
		{	*type = SOAP_TYPE__ns1__checkSNOrderNoResponse;
			return soap_in__ns1__checkSNOrderNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkSNOrderNo"))
		{	*type = SOAP_TYPE__ns1__checkSNOrderNo;
			return soap_in__ns1__checkSNOrderNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadNgPanelNoResponse"))
		{	*type = SOAP_TYPE__ns1__loadNgPanelNoResponse;
			return soap_in__ns1__loadNgPanelNoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadNgPanelNo"))
		{	*type = SOAP_TYPE__ns1__loadNgPanelNo;
			return soap_in__ns1__loadNgPanelNo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadTimeControlDataResponse"))
		{	*type = SOAP_TYPE__ns1__loadTimeControlDataResponse;
			return soap_in__ns1__loadTimeControlDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadTimeControlData"))
		{	*type = SOAP_TYPE__ns1__loadTimeControlData;
			return soap_in__ns1__loadTimeControlData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bindAssemblyResponse"))
		{	*type = SOAP_TYPE__ns1__bindAssemblyResponse;
			return soap_in__ns1__bindAssemblyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bindAssembly"))
		{	*type = SOAP_TYPE__ns1__bindAssembly;
			return soap_in__ns1__bindAssembly(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnSaveTechProcessResponse"))
		{	*type = SOAP_TYPE__ns1__SnSaveTechProcessResponse;
			return soap_in__ns1__SnSaveTechProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnSaveTechProcess"))
		{	*type = SOAP_TYPE__ns1__SnSaveTechProcess;
			return soap_in__ns1__SnSaveTechProcess(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__CheckTimeGapResponse:
		return ((_ns1__CheckTimeGapResponse *)ptr)->soap_out(soap, "ns1:CheckTimeGapResponse", id, NULL);
	case SOAP_TYPE__ns1__CheckTimeGap:
		return ((_ns1__CheckTimeGap *)ptr)->soap_out(soap, "ns1:CheckTimeGap", id, NULL);
	case SOAP_TYPE__ns1__IspasspostburninResponse:
		return ((_ns1__IspasspostburninResponse *)ptr)->soap_out(soap, "ns1:IspasspostburninResponse", id, NULL);
	case SOAP_TYPE__ns1__Ispasspostburnin:
		return ((_ns1__Ispasspostburnin *)ptr)->soap_out(soap, "ns1:Ispasspostburnin", id, NULL);
	case SOAP_TYPE__ns1__checkingSNNextRouteResponse:
		return ((_ns1__checkingSNNextRouteResponse *)ptr)->soap_out(soap, "ns1:checkingSNNextRouteResponse", id, NULL);
	case SOAP_TYPE__ns1__checkingSNNextRoute:
		return ((_ns1__checkingSNNextRoute *)ptr)->soap_out(soap, "ns1:checkingSNNextRoute", id, NULL);
	case SOAP_TYPE__ns1__blakeTestExchangeDataResponse:
		return ((_ns1__blakeTestExchangeDataResponse *)ptr)->soap_out(soap, "ns1:blakeTestExchangeDataResponse", id, NULL);
	case SOAP_TYPE__ns1__blakeTestExchangeData:
		return ((_ns1__blakeTestExchangeData *)ptr)->soap_out(soap, "ns1:blakeTestExchangeData", id, NULL);
	case SOAP_TYPE__ns1__goNewRouteseqResponse:
		return ((_ns1__goNewRouteseqResponse *)ptr)->soap_out(soap, "ns1:goNewRouteseqResponse", id, NULL);
	case SOAP_TYPE__ns1__goNewRouteseq:
		return ((_ns1__goNewRouteseq *)ptr)->soap_out(soap, "ns1:goNewRouteseq", id, NULL);
	case SOAP_TYPE__ns1__fetchSnCurrentLocationResponse:
		return ((_ns1__fetchSnCurrentLocationResponse *)ptr)->soap_out(soap, "ns1:fetchSnCurrentLocationResponse", id, NULL);
	case SOAP_TYPE__ns1__fetchSnCurrentLocation:
		return ((_ns1__fetchSnCurrentLocation *)ptr)->soap_out(soap, "ns1:fetchSnCurrentLocation", id, NULL);
	case SOAP_TYPE__ns1__getMaintanceParmResponse:
		return ((_ns1__getMaintanceParmResponse *)ptr)->soap_out(soap, "ns1:getMaintanceParmResponse", id, NULL);
	case SOAP_TYPE__ns1__getMaintanceParm:
		return ((_ns1__getMaintanceParm *)ptr)->soap_out(soap, "ns1:getMaintanceParm", id, NULL);
	case SOAP_TYPE__ns1__checkMacResponse:
		return ((_ns1__checkMacResponse *)ptr)->soap_out(soap, "ns1:checkMacResponse", id, NULL);
	case SOAP_TYPE__ns1__checkMac:
		return ((_ns1__checkMac *)ptr)->soap_out(soap, "ns1:checkMac", id, NULL);
	case SOAP_TYPE__ns1__InsertTimeControlResponse:
		return ((_ns1__InsertTimeControlResponse *)ptr)->soap_out(soap, "ns1:InsertTimeControlResponse", id, NULL);
	case SOAP_TYPE__ns1__InsertTimeControl:
		return ((_ns1__InsertTimeControl *)ptr)->soap_out(soap, "ns1:InsertTimeControl", id, NULL);
	case SOAP_TYPE__ns1__blakeTestExchangeData1Response:
		return ((_ns1__blakeTestExchangeData1Response *)ptr)->soap_out(soap, "ns1:blakeTestExchangeData1Response", id, NULL);
	case SOAP_TYPE__ns1__blakeTestExchangeData1:
		return ((_ns1__blakeTestExchangeData1 *)ptr)->soap_out(soap, "ns1:blakeTestExchangeData1", id, NULL);
	case SOAP_TYPE__ns1__InsertPRateDataResponse:
		return ((_ns1__InsertPRateDataResponse *)ptr)->soap_out(soap, "ns1:InsertPRateDataResponse", id, NULL);
	case SOAP_TYPE__ns1__InsertPRateData:
		return ((_ns1__InsertPRateData *)ptr)->soap_out(soap, "ns1:InsertPRateData", id, NULL);
	case SOAP_TYPE__ns1__getAssemblyDataResponse:
		return ((_ns1__getAssemblyDataResponse *)ptr)->soap_out(soap, "ns1:getAssemblyDataResponse", id, NULL);
	case SOAP_TYPE__ns1__getAssemblyData:
		return ((_ns1__getAssemblyData *)ptr)->soap_out(soap, "ns1:getAssemblyData", id, NULL);
	case SOAP_TYPE__ns1__staffCheckResponse:
		return ((_ns1__staffCheckResponse *)ptr)->soap_out(soap, "ns1:staffCheckResponse", id, NULL);
	case SOAP_TYPE__ns1__staffCheck:
		return ((_ns1__staffCheck *)ptr)->soap_out(soap, "ns1:staffCheck", id, NULL);
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse:
		return ((_ns1__SnSaveTechProcess_USCOREAResponse *)ptr)->soap_out(soap, "ns1:SnSaveTechProcess_AResponse", id, NULL);
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA:
		return ((_ns1__SnSaveTechProcess_USCOREA *)ptr)->soap_out(soap, "ns1:SnSaveTechProcess_A", id, NULL);
	case SOAP_TYPE__ns1__checkSNPangusOrderNoResponse:
		return ((_ns1__checkSNPangusOrderNoResponse *)ptr)->soap_out(soap, "ns1:checkSNPangusOrderNoResponse", id, NULL);
	case SOAP_TYPE__ns1__checkSNPangusOrderNo:
		return ((_ns1__checkSNPangusOrderNo *)ptr)->soap_out(soap, "ns1:checkSNPangusOrderNo", id, NULL);
	case SOAP_TYPE__ns1__checkSNOrderNoResponse:
		return ((_ns1__checkSNOrderNoResponse *)ptr)->soap_out(soap, "ns1:checkSNOrderNoResponse", id, NULL);
	case SOAP_TYPE__ns1__checkSNOrderNo:
		return ((_ns1__checkSNOrderNo *)ptr)->soap_out(soap, "ns1:checkSNOrderNo", id, NULL);
	case SOAP_TYPE__ns1__loadNgPanelNoResponse:
		return ((_ns1__loadNgPanelNoResponse *)ptr)->soap_out(soap, "ns1:loadNgPanelNoResponse", id, NULL);
	case SOAP_TYPE__ns1__loadNgPanelNo:
		return ((_ns1__loadNgPanelNo *)ptr)->soap_out(soap, "ns1:loadNgPanelNo", id, NULL);
	case SOAP_TYPE__ns1__loadTimeControlDataResponse:
		return ((_ns1__loadTimeControlDataResponse *)ptr)->soap_out(soap, "ns1:loadTimeControlDataResponse", id, NULL);
	case SOAP_TYPE__ns1__loadTimeControlData:
		return ((_ns1__loadTimeControlData *)ptr)->soap_out(soap, "ns1:loadTimeControlData", id, NULL);
	case SOAP_TYPE__ns1__bindAssemblyResponse:
		return ((_ns1__bindAssemblyResponse *)ptr)->soap_out(soap, "ns1:bindAssemblyResponse", id, NULL);
	case SOAP_TYPE__ns1__bindAssembly:
		return ((_ns1__bindAssembly *)ptr)->soap_out(soap, "ns1:bindAssembly", id, NULL);
	case SOAP_TYPE__ns1__SnSaveTechProcessResponse:
		return ((_ns1__SnSaveTechProcessResponse *)ptr)->soap_out(soap, "ns1:SnSaveTechProcessResponse", id, NULL);
	case SOAP_TYPE__ns1__SnSaveTechProcess:
		return ((_ns1__SnSaveTechProcess *)ptr)->soap_out(soap, "ns1:SnSaveTechProcess", id, NULL);
	case SOAP_TYPE_PointerTo_ns1__CheckTimeGap:
		return soap_out_PointerTo_ns1__CheckTimeGap(soap, tag, id, (_ns1__CheckTimeGap *const*)ptr, "ns1:CheckTimeGap");
	case SOAP_TYPE_PointerTo_ns1__Ispasspostburnin:
		return soap_out_PointerTo_ns1__Ispasspostburnin(soap, tag, id, (_ns1__Ispasspostburnin *const*)ptr, "ns1:Ispasspostburnin");
	case SOAP_TYPE_PointerTo_ns1__checkingSNNextRoute:
		return soap_out_PointerTo_ns1__checkingSNNextRoute(soap, tag, id, (_ns1__checkingSNNextRoute *const*)ptr, "ns1:checkingSNNextRoute");
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData:
		return soap_out_PointerTo_ns1__blakeTestExchangeData(soap, tag, id, (_ns1__blakeTestExchangeData *const*)ptr, "ns1:blakeTestExchangeData");
	case SOAP_TYPE_PointerTo_ns1__goNewRouteseq:
		return soap_out_PointerTo_ns1__goNewRouteseq(soap, tag, id, (_ns1__goNewRouteseq *const*)ptr, "ns1:goNewRouteseq");
	case SOAP_TYPE_PointerTo_ns1__fetchSnCurrentLocation:
		return soap_out_PointerTo_ns1__fetchSnCurrentLocation(soap, tag, id, (_ns1__fetchSnCurrentLocation *const*)ptr, "ns1:fetchSnCurrentLocation");
	case SOAP_TYPE_PointerTo_ns1__getMaintanceParm:
		return soap_out_PointerTo_ns1__getMaintanceParm(soap, tag, id, (_ns1__getMaintanceParm *const*)ptr, "ns1:getMaintanceParm");
	case SOAP_TYPE_PointerTo_ns1__checkMac:
		return soap_out_PointerTo_ns1__checkMac(soap, tag, id, (_ns1__checkMac *const*)ptr, "ns1:checkMac");
	case SOAP_TYPE_PointerTo_ns1__InsertTimeControl:
		return soap_out_PointerTo_ns1__InsertTimeControl(soap, tag, id, (_ns1__InsertTimeControl *const*)ptr, "ns1:InsertTimeControl");
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData1:
		return soap_out_PointerTo_ns1__blakeTestExchangeData1(soap, tag, id, (_ns1__blakeTestExchangeData1 *const*)ptr, "ns1:blakeTestExchangeData1");
	case SOAP_TYPE_PointerTo_ns1__InsertPRateData:
		return soap_out_PointerTo_ns1__InsertPRateData(soap, tag, id, (_ns1__InsertPRateData *const*)ptr, "ns1:InsertPRateData");
	case SOAP_TYPE_PointerTo_ns1__getAssemblyData:
		return soap_out_PointerTo_ns1__getAssemblyData(soap, tag, id, (_ns1__getAssemblyData *const*)ptr, "ns1:getAssemblyData");
	case SOAP_TYPE_PointerTo_ns1__staffCheck:
		return soap_out_PointerTo_ns1__staffCheck(soap, tag, id, (_ns1__staffCheck *const*)ptr, "ns1:staffCheck");
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess_USCOREA:
		return soap_out_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, tag, id, (_ns1__SnSaveTechProcess_USCOREA *const*)ptr, "ns1:SnSaveTechProcess_A");
	case SOAP_TYPE_PointerTo_ns1__checkSNPangusOrderNo:
		return soap_out_PointerTo_ns1__checkSNPangusOrderNo(soap, tag, id, (_ns1__checkSNPangusOrderNo *const*)ptr, "ns1:checkSNPangusOrderNo");
	case SOAP_TYPE_PointerTo_ns1__checkSNOrderNo:
		return soap_out_PointerTo_ns1__checkSNOrderNo(soap, tag, id, (_ns1__checkSNOrderNo *const*)ptr, "ns1:checkSNOrderNo");
	case SOAP_TYPE_PointerTo_ns1__loadNgPanelNo:
		return soap_out_PointerTo_ns1__loadNgPanelNo(soap, tag, id, (_ns1__loadNgPanelNo *const*)ptr, "ns1:loadNgPanelNo");
	case SOAP_TYPE_PointerTo_ns1__loadTimeControlData:
		return soap_out_PointerTo_ns1__loadTimeControlData(soap, tag, id, (_ns1__loadTimeControlData *const*)ptr, "ns1:loadTimeControlData");
	case SOAP_TYPE_PointerTo_ns1__bindAssembly:
		return soap_out_PointerTo_ns1__bindAssembly(soap, tag, id, (_ns1__bindAssembly *const*)ptr, "ns1:bindAssembly");
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess:
		return soap_out_PointerTo_ns1__SnSaveTechProcess(soap, tag, id, (_ns1__SnSaveTechProcess *const*)ptr, "ns1:SnSaveTechProcess");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__CheckTimeGapResponse:
		((_ns1__CheckTimeGapResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckTimeGap:
		((_ns1__CheckTimeGap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IspasspostburninResponse:
		((_ns1__IspasspostburninResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Ispasspostburnin:
		((_ns1__Ispasspostburnin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkingSNNextRouteResponse:
		((_ns1__checkingSNNextRouteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkingSNNextRoute:
		((_ns1__checkingSNNextRoute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeDataResponse:
		((_ns1__blakeTestExchangeDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData:
		((_ns1__blakeTestExchangeData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__goNewRouteseqResponse:
		((_ns1__goNewRouteseqResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__goNewRouteseq:
		((_ns1__goNewRouteseq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocationResponse:
		((_ns1__fetchSnCurrentLocationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocation:
		((_ns1__fetchSnCurrentLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMaintanceParmResponse:
		((_ns1__getMaintanceParmResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getMaintanceParm:
		((_ns1__getMaintanceParm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkMacResponse:
		((_ns1__checkMacResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkMac:
		((_ns1__checkMac *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertTimeControlResponse:
		((_ns1__InsertTimeControlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertTimeControl:
		((_ns1__InsertTimeControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1Response:
		((_ns1__blakeTestExchangeData1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1:
		((_ns1__blakeTestExchangeData1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertPRateDataResponse:
		((_ns1__InsertPRateDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InsertPRateData:
		((_ns1__InsertPRateData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAssemblyDataResponse:
		((_ns1__getAssemblyDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getAssemblyData:
		((_ns1__getAssemblyData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__staffCheckResponse:
		((_ns1__staffCheckResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__staffCheck:
		((_ns1__staffCheck *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse:
		((_ns1__SnSaveTechProcess_USCOREAResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA:
		((_ns1__SnSaveTechProcess_USCOREA *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNoResponse:
		((_ns1__checkSNPangusOrderNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNo:
		((_ns1__checkSNPangusOrderNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSNOrderNoResponse:
		((_ns1__checkSNOrderNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__checkSNOrderNo:
		((_ns1__checkSNOrderNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loadNgPanelNoResponse:
		((_ns1__loadNgPanelNoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loadNgPanelNo:
		((_ns1__loadNgPanelNo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loadTimeControlDataResponse:
		((_ns1__loadTimeControlDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loadTimeControlData:
		((_ns1__loadTimeControlData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__bindAssemblyResponse:
		((_ns1__bindAssemblyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__bindAssembly:
		((_ns1__bindAssembly *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcessResponse:
		((_ns1__SnSaveTechProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess:
		((_ns1__SnSaveTechProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__CheckTimeGap:
		soap_serialize___ns1__CheckTimeGap(soap, (const struct __ns1__CheckTimeGap *)ptr);
		break;
	case SOAP_TYPE___ns1__Ispasspostburnin:
		soap_serialize___ns1__Ispasspostburnin(soap, (const struct __ns1__Ispasspostburnin *)ptr);
		break;
	case SOAP_TYPE___ns1__checkingSNNextRoute:
		soap_serialize___ns1__checkingSNNextRoute(soap, (const struct __ns1__checkingSNNextRoute *)ptr);
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData:
		soap_serialize___ns1__blakeTestExchangeData(soap, (const struct __ns1__blakeTestExchangeData *)ptr);
		break;
	case SOAP_TYPE___ns1__goNewRouteseq:
		soap_serialize___ns1__goNewRouteseq(soap, (const struct __ns1__goNewRouteseq *)ptr);
		break;
	case SOAP_TYPE___ns1__fetchSnCurrentLocation:
		soap_serialize___ns1__fetchSnCurrentLocation(soap, (const struct __ns1__fetchSnCurrentLocation *)ptr);
		break;
	case SOAP_TYPE___ns1__getMaintanceParm:
		soap_serialize___ns1__getMaintanceParm(soap, (const struct __ns1__getMaintanceParm *)ptr);
		break;
	case SOAP_TYPE___ns1__checkMac:
		soap_serialize___ns1__checkMac(soap, (const struct __ns1__checkMac *)ptr);
		break;
	case SOAP_TYPE___ns1__InsertTimeControl:
		soap_serialize___ns1__InsertTimeControl(soap, (const struct __ns1__InsertTimeControl *)ptr);
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData1:
		soap_serialize___ns1__blakeTestExchangeData1(soap, (const struct __ns1__blakeTestExchangeData1 *)ptr);
		break;
	case SOAP_TYPE___ns1__InsertPRateData:
		soap_serialize___ns1__InsertPRateData(soap, (const struct __ns1__InsertPRateData *)ptr);
		break;
	case SOAP_TYPE___ns1__getAssemblyData:
		soap_serialize___ns1__getAssemblyData(soap, (const struct __ns1__getAssemblyData *)ptr);
		break;
	case SOAP_TYPE___ns1__staffCheck:
		soap_serialize___ns1__staffCheck(soap, (const struct __ns1__staffCheck *)ptr);
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA:
		soap_serialize___ns1__SnSaveTechProcess_USCOREA(soap, (const struct __ns1__SnSaveTechProcess_USCOREA *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSNPangusOrderNo:
		soap_serialize___ns1__checkSNPangusOrderNo(soap, (const struct __ns1__checkSNPangusOrderNo *)ptr);
		break;
	case SOAP_TYPE___ns1__checkSNOrderNo:
		soap_serialize___ns1__checkSNOrderNo(soap, (const struct __ns1__checkSNOrderNo *)ptr);
		break;
	case SOAP_TYPE___ns1__loadNgPanelNo:
		soap_serialize___ns1__loadNgPanelNo(soap, (const struct __ns1__loadNgPanelNo *)ptr);
		break;
	case SOAP_TYPE___ns1__loadTimeControlData:
		soap_serialize___ns1__loadTimeControlData(soap, (const struct __ns1__loadTimeControlData *)ptr);
		break;
	case SOAP_TYPE___ns1__bindAssembly:
		soap_serialize___ns1__bindAssembly(soap, (const struct __ns1__bindAssembly *)ptr);
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess:
		soap_serialize___ns1__SnSaveTechProcess(soap, (const struct __ns1__SnSaveTechProcess *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckTimeGap:
		soap_serialize_PointerTo_ns1__CheckTimeGap(soap, (_ns1__CheckTimeGap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Ispasspostburnin:
		soap_serialize_PointerTo_ns1__Ispasspostburnin(soap, (_ns1__Ispasspostburnin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkingSNNextRoute:
		soap_serialize_PointerTo_ns1__checkingSNNextRoute(soap, (_ns1__checkingSNNextRoute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData:
		soap_serialize_PointerTo_ns1__blakeTestExchangeData(soap, (_ns1__blakeTestExchangeData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__goNewRouteseq:
		soap_serialize_PointerTo_ns1__goNewRouteseq(soap, (_ns1__goNewRouteseq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__fetchSnCurrentLocation:
		soap_serialize_PointerTo_ns1__fetchSnCurrentLocation(soap, (_ns1__fetchSnCurrentLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getMaintanceParm:
		soap_serialize_PointerTo_ns1__getMaintanceParm(soap, (_ns1__getMaintanceParm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkMac:
		soap_serialize_PointerTo_ns1__checkMac(soap, (_ns1__checkMac *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsertTimeControl:
		soap_serialize_PointerTo_ns1__InsertTimeControl(soap, (_ns1__InsertTimeControl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData1:
		soap_serialize_PointerTo_ns1__blakeTestExchangeData1(soap, (_ns1__blakeTestExchangeData1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InsertPRateData:
		soap_serialize_PointerTo_ns1__InsertPRateData(soap, (_ns1__InsertPRateData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAssemblyData:
		soap_serialize_PointerTo_ns1__getAssemblyData(soap, (_ns1__getAssemblyData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__staffCheck:
		soap_serialize_PointerTo_ns1__staffCheck(soap, (_ns1__staffCheck *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess_USCOREA:
		soap_serialize_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, (_ns1__SnSaveTechProcess_USCOREA *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkSNPangusOrderNo:
		soap_serialize_PointerTo_ns1__checkSNPangusOrderNo(soap, (_ns1__checkSNPangusOrderNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__checkSNOrderNo:
		soap_serialize_PointerTo_ns1__checkSNOrderNo(soap, (_ns1__checkSNOrderNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loadNgPanelNo:
		soap_serialize_PointerTo_ns1__loadNgPanelNo(soap, (_ns1__loadNgPanelNo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loadTimeControlData:
		soap_serialize_PointerTo_ns1__loadTimeControlData(soap, (_ns1__loadTimeControlData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__bindAssembly:
		soap_serialize_PointerTo_ns1__bindAssembly(soap, (_ns1__bindAssembly *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess:
		soap_serialize_PointerTo_ns1__SnSaveTechProcess(soap, (_ns1__SnSaveTechProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnSaveTechProcess:
		return (void*)soap_instantiate__ns1__SnSaveTechProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnSaveTechProcessResponse:
		return (void*)soap_instantiate__ns1__SnSaveTechProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__bindAssembly:
		return (void*)soap_instantiate__ns1__bindAssembly(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__bindAssemblyResponse:
		return (void*)soap_instantiate__ns1__bindAssemblyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loadTimeControlData:
		return (void*)soap_instantiate__ns1__loadTimeControlData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loadTimeControlDataResponse:
		return (void*)soap_instantiate__ns1__loadTimeControlDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loadNgPanelNo:
		return (void*)soap_instantiate__ns1__loadNgPanelNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loadNgPanelNoResponse:
		return (void*)soap_instantiate__ns1__loadNgPanelNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSNOrderNo:
		return (void*)soap_instantiate__ns1__checkSNOrderNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSNOrderNoResponse:
		return (void*)soap_instantiate__ns1__checkSNOrderNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSNPangusOrderNo:
		return (void*)soap_instantiate__ns1__checkSNPangusOrderNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkSNPangusOrderNoResponse:
		return (void*)soap_instantiate__ns1__checkSNPangusOrderNoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA:
		return (void*)soap_instantiate__ns1__SnSaveTechProcess_USCOREA(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse:
		return (void*)soap_instantiate__ns1__SnSaveTechProcess_USCOREAResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__staffCheck:
		return (void*)soap_instantiate__ns1__staffCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__staffCheckResponse:
		return (void*)soap_instantiate__ns1__staffCheckResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAssemblyData:
		return (void*)soap_instantiate__ns1__getAssemblyData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getAssemblyDataResponse:
		return (void*)soap_instantiate__ns1__getAssemblyDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertPRateData:
		return (void*)soap_instantiate__ns1__InsertPRateData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertPRateDataResponse:
		return (void*)soap_instantiate__ns1__InsertPRateDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__blakeTestExchangeData1:
		return (void*)soap_instantiate__ns1__blakeTestExchangeData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__blakeTestExchangeData1Response:
		return (void*)soap_instantiate__ns1__blakeTestExchangeData1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertTimeControl:
		return (void*)soap_instantiate__ns1__InsertTimeControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InsertTimeControlResponse:
		return (void*)soap_instantiate__ns1__InsertTimeControlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkMac:
		return (void*)soap_instantiate__ns1__checkMac(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkMacResponse:
		return (void*)soap_instantiate__ns1__checkMacResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMaintanceParm:
		return (void*)soap_instantiate__ns1__getMaintanceParm(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getMaintanceParmResponse:
		return (void*)soap_instantiate__ns1__getMaintanceParmResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__fetchSnCurrentLocation:
		return (void*)soap_instantiate__ns1__fetchSnCurrentLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__fetchSnCurrentLocationResponse:
		return (void*)soap_instantiate__ns1__fetchSnCurrentLocationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__goNewRouteseq:
		return (void*)soap_instantiate__ns1__goNewRouteseq(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__goNewRouteseqResponse:
		return (void*)soap_instantiate__ns1__goNewRouteseqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__blakeTestExchangeData:
		return (void*)soap_instantiate__ns1__blakeTestExchangeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__blakeTestExchangeDataResponse:
		return (void*)soap_instantiate__ns1__blakeTestExchangeDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkingSNNextRoute:
		return (void*)soap_instantiate__ns1__checkingSNNextRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__checkingSNNextRouteResponse:
		return (void*)soap_instantiate__ns1__checkingSNNextRouteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Ispasspostburnin:
		return (void*)soap_instantiate__ns1__Ispasspostburnin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IspasspostburninResponse:
		return (void*)soap_instantiate__ns1__IspasspostburninResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckTimeGap:
		return (void*)soap_instantiate__ns1__CheckTimeGap(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckTimeGapResponse:
		return (void*)soap_instantiate__ns1__CheckTimeGapResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnSaveTechProcess:
		return (void*)soap_instantiate___ns1__SnSaveTechProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__bindAssembly:
		return (void*)soap_instantiate___ns1__bindAssembly(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadTimeControlData:
		return (void*)soap_instantiate___ns1__loadTimeControlData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__loadNgPanelNo:
		return (void*)soap_instantiate___ns1__loadNgPanelNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSNOrderNo:
		return (void*)soap_instantiate___ns1__checkSNOrderNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkSNPangusOrderNo:
		return (void*)soap_instantiate___ns1__checkSNPangusOrderNo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA:
		return (void*)soap_instantiate___ns1__SnSaveTechProcess_USCOREA(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__staffCheck:
		return (void*)soap_instantiate___ns1__staffCheck(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAssemblyData:
		return (void*)soap_instantiate___ns1__getAssemblyData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsertPRateData:
		return (void*)soap_instantiate___ns1__InsertPRateData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__blakeTestExchangeData1:
		return (void*)soap_instantiate___ns1__blakeTestExchangeData1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InsertTimeControl:
		return (void*)soap_instantiate___ns1__InsertTimeControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkMac:
		return (void*)soap_instantiate___ns1__checkMac(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMaintanceParm:
		return (void*)soap_instantiate___ns1__getMaintanceParm(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fetchSnCurrentLocation:
		return (void*)soap_instantiate___ns1__fetchSnCurrentLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__goNewRouteseq:
		return (void*)soap_instantiate___ns1__goNewRouteseq(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__blakeTestExchangeData:
		return (void*)soap_instantiate___ns1__blakeTestExchangeData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkingSNNextRoute:
		return (void*)soap_instantiate___ns1__checkingSNNextRoute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Ispasspostburnin:
		return (void*)soap_instantiate___ns1__Ispasspostburnin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckTimeGap:
		return (void*)soap_instantiate___ns1__CheckTimeGap(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnSaveTechProcess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnSaveTechProcess*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcessResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnSaveTechProcessResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnSaveTechProcessResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__bindAssembly:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__bindAssembly*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__bindAssembly*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__bindAssemblyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__bindAssemblyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__bindAssemblyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__loadTimeControlData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__loadTimeControlData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__loadTimeControlData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__loadTimeControlDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__loadTimeControlDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__loadTimeControlDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__loadNgPanelNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__loadNgPanelNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__loadNgPanelNo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__loadNgPanelNoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__loadNgPanelNoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__loadNgPanelNoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSNOrderNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSNOrderNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSNOrderNo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSNOrderNoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSNOrderNoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSNOrderNoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSNPangusOrderNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSNPangusOrderNo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkSNPangusOrderNoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkSNPangusOrderNoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnSaveTechProcess_USCOREA*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnSaveTechProcess_USCOREA*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SnSaveTechProcess_USCOREAResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SnSaveTechProcess_USCOREAResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__staffCheck:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__staffCheck*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__staffCheck*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__staffCheckResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__staffCheckResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__staffCheckResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getAssemblyData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getAssemblyData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getAssemblyData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getAssemblyDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getAssemblyDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getAssemblyDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsertPRateData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsertPRateData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsertPRateData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsertPRateDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsertPRateDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsertPRateDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__blakeTestExchangeData1*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__blakeTestExchangeData1*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1Response:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__blakeTestExchangeData1Response*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__blakeTestExchangeData1Response*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsertTimeControl:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsertTimeControl*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsertTimeControl*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InsertTimeControlResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InsertTimeControlResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InsertTimeControlResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkMac:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkMac*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkMac*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkMacResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkMacResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkMacResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMaintanceParm:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMaintanceParm*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMaintanceParm*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getMaintanceParmResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getMaintanceParmResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getMaintanceParmResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__fetchSnCurrentLocation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__fetchSnCurrentLocation*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__fetchSnCurrentLocationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__fetchSnCurrentLocationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__goNewRouteseq:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__goNewRouteseq*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__goNewRouteseq*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__goNewRouteseqResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__goNewRouteseqResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__goNewRouteseqResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__blakeTestExchangeData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__blakeTestExchangeData*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeDataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__blakeTestExchangeDataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__blakeTestExchangeDataResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkingSNNextRoute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkingSNNextRoute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkingSNNextRoute*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__checkingSNNextRouteResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__checkingSNNextRouteResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__checkingSNNextRouteResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Ispasspostburnin:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Ispasspostburnin*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Ispasspostburnin*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__IspasspostburninResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__IspasspostburninResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__IspasspostburninResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CheckTimeGap:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CheckTimeGap*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CheckTimeGap*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CheckTimeGapResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CheckTimeGapResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CheckTimeGapResponse*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnSaveTechProcess*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnSaveTechProcess*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__bindAssembly:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__bindAssembly*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__bindAssembly*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__loadTimeControlData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__loadTimeControlData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__loadTimeControlData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__loadNgPanelNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__loadNgPanelNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__loadNgPanelNo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSNOrderNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSNOrderNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSNOrderNo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkSNPangusOrderNo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkSNPangusOrderNo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkSNPangusOrderNo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SnSaveTechProcess_USCOREA*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SnSaveTechProcess_USCOREA*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__staffCheck:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__staffCheck*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__staffCheck*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getAssemblyData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getAssemblyData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getAssemblyData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsertPRateData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsertPRateData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsertPRateData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData1:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__blakeTestExchangeData1*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__blakeTestExchangeData1*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__InsertTimeControl:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__InsertTimeControl*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__InsertTimeControl*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkMac:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkMac*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkMac*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getMaintanceParm:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getMaintanceParm*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getMaintanceParm*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__fetchSnCurrentLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__fetchSnCurrentLocation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__fetchSnCurrentLocation*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__goNewRouteseq:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__goNewRouteseq*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__goNewRouteseq*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__blakeTestExchangeData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__blakeTestExchangeData*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__checkingSNNextRoute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__checkingSNNextRoute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__checkingSNNextRoute*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Ispasspostburnin:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Ispasspostburnin*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Ispasspostburnin*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CheckTimeGap:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CheckTimeGap*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CheckTimeGap*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnSaveTechProcess type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnSaveTechProcess*)p = *(_ns1__SnSaveTechProcess*)q;
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnSaveTechProcessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnSaveTechProcessResponse*)p = *(_ns1__SnSaveTechProcessResponse*)q;
		break;
	case SOAP_TYPE__ns1__bindAssembly:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__bindAssembly type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__bindAssembly*)p = *(_ns1__bindAssembly*)q;
		break;
	case SOAP_TYPE__ns1__bindAssemblyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__bindAssemblyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__bindAssemblyResponse*)p = *(_ns1__bindAssemblyResponse*)q;
		break;
	case SOAP_TYPE__ns1__loadTimeControlData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loadTimeControlData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loadTimeControlData*)p = *(_ns1__loadTimeControlData*)q;
		break;
	case SOAP_TYPE__ns1__loadTimeControlDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loadTimeControlDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loadTimeControlDataResponse*)p = *(_ns1__loadTimeControlDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__loadNgPanelNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loadNgPanelNo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loadNgPanelNo*)p = *(_ns1__loadNgPanelNo*)q;
		break;
	case SOAP_TYPE__ns1__loadNgPanelNoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__loadNgPanelNoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__loadNgPanelNoResponse*)p = *(_ns1__loadNgPanelNoResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkSNOrderNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSNOrderNo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSNOrderNo*)p = *(_ns1__checkSNOrderNo*)q;
		break;
	case SOAP_TYPE__ns1__checkSNOrderNoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSNOrderNoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSNOrderNoResponse*)p = *(_ns1__checkSNOrderNoResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSNPangusOrderNo type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSNPangusOrderNo*)p = *(_ns1__checkSNPangusOrderNo*)q;
		break;
	case SOAP_TYPE__ns1__checkSNPangusOrderNoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkSNPangusOrderNoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkSNPangusOrderNoResponse*)p = *(_ns1__checkSNPangusOrderNoResponse*)q;
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnSaveTechProcess_USCOREA type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnSaveTechProcess_USCOREA*)p = *(_ns1__SnSaveTechProcess_USCOREA*)q;
		break;
	case SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SnSaveTechProcess_USCOREAResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SnSaveTechProcess_USCOREAResponse*)p = *(_ns1__SnSaveTechProcess_USCOREAResponse*)q;
		break;
	case SOAP_TYPE__ns1__staffCheck:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__staffCheck type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__staffCheck*)p = *(_ns1__staffCheck*)q;
		break;
	case SOAP_TYPE__ns1__staffCheckResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__staffCheckResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__staffCheckResponse*)p = *(_ns1__staffCheckResponse*)q;
		break;
	case SOAP_TYPE__ns1__getAssemblyData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getAssemblyData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getAssemblyData*)p = *(_ns1__getAssemblyData*)q;
		break;
	case SOAP_TYPE__ns1__getAssemblyDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getAssemblyDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getAssemblyDataResponse*)p = *(_ns1__getAssemblyDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__InsertPRateData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsertPRateData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsertPRateData*)p = *(_ns1__InsertPRateData*)q;
		break;
	case SOAP_TYPE__ns1__InsertPRateDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsertPRateDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsertPRateDataResponse*)p = *(_ns1__InsertPRateDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__blakeTestExchangeData1 type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__blakeTestExchangeData1*)p = *(_ns1__blakeTestExchangeData1*)q;
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData1Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__blakeTestExchangeData1Response type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__blakeTestExchangeData1Response*)p = *(_ns1__blakeTestExchangeData1Response*)q;
		break;
	case SOAP_TYPE__ns1__InsertTimeControl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsertTimeControl type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsertTimeControl*)p = *(_ns1__InsertTimeControl*)q;
		break;
	case SOAP_TYPE__ns1__InsertTimeControlResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InsertTimeControlResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InsertTimeControlResponse*)p = *(_ns1__InsertTimeControlResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkMac:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkMac type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkMac*)p = *(_ns1__checkMac*)q;
		break;
	case SOAP_TYPE__ns1__checkMacResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkMacResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkMacResponse*)p = *(_ns1__checkMacResponse*)q;
		break;
	case SOAP_TYPE__ns1__getMaintanceParm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMaintanceParm type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMaintanceParm*)p = *(_ns1__getMaintanceParm*)q;
		break;
	case SOAP_TYPE__ns1__getMaintanceParmResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getMaintanceParmResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getMaintanceParmResponse*)p = *(_ns1__getMaintanceParmResponse*)q;
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__fetchSnCurrentLocation type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__fetchSnCurrentLocation*)p = *(_ns1__fetchSnCurrentLocation*)q;
		break;
	case SOAP_TYPE__ns1__fetchSnCurrentLocationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__fetchSnCurrentLocationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__fetchSnCurrentLocationResponse*)p = *(_ns1__fetchSnCurrentLocationResponse*)q;
		break;
	case SOAP_TYPE__ns1__goNewRouteseq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__goNewRouteseq type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__goNewRouteseq*)p = *(_ns1__goNewRouteseq*)q;
		break;
	case SOAP_TYPE__ns1__goNewRouteseqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__goNewRouteseqResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__goNewRouteseqResponse*)p = *(_ns1__goNewRouteseqResponse*)q;
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__blakeTestExchangeData type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__blakeTestExchangeData*)p = *(_ns1__blakeTestExchangeData*)q;
		break;
	case SOAP_TYPE__ns1__blakeTestExchangeDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__blakeTestExchangeDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__blakeTestExchangeDataResponse*)p = *(_ns1__blakeTestExchangeDataResponse*)q;
		break;
	case SOAP_TYPE__ns1__checkingSNNextRoute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkingSNNextRoute type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkingSNNextRoute*)p = *(_ns1__checkingSNNextRoute*)q;
		break;
	case SOAP_TYPE__ns1__checkingSNNextRouteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__checkingSNNextRouteResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__checkingSNNextRouteResponse*)p = *(_ns1__checkingSNNextRouteResponse*)q;
		break;
	case SOAP_TYPE__ns1__Ispasspostburnin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Ispasspostburnin type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Ispasspostburnin*)p = *(_ns1__Ispasspostburnin*)q;
		break;
	case SOAP_TYPE__ns1__IspasspostburninResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IspasspostburninResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IspasspostburninResponse*)p = *(_ns1__IspasspostburninResponse*)q;
		break;
	case SOAP_TYPE__ns1__CheckTimeGap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckTimeGap type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckTimeGap*)p = *(_ns1__CheckTimeGap*)q;
		break;
	case SOAP_TYPE__ns1__CheckTimeGapResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CheckTimeGapResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CheckTimeGapResponse*)p = *(_ns1__CheckTimeGapResponse*)q;
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnSaveTechProcess type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnSaveTechProcess*)p = *(struct __ns1__SnSaveTechProcess*)q;
		break;
	case SOAP_TYPE___ns1__bindAssembly:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__bindAssembly type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__bindAssembly*)p = *(struct __ns1__bindAssembly*)q;
		break;
	case SOAP_TYPE___ns1__loadTimeControlData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__loadTimeControlData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__loadTimeControlData*)p = *(struct __ns1__loadTimeControlData*)q;
		break;
	case SOAP_TYPE___ns1__loadNgPanelNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__loadNgPanelNo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__loadNgPanelNo*)p = *(struct __ns1__loadNgPanelNo*)q;
		break;
	case SOAP_TYPE___ns1__checkSNOrderNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSNOrderNo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSNOrderNo*)p = *(struct __ns1__checkSNOrderNo*)q;
		break;
	case SOAP_TYPE___ns1__checkSNPangusOrderNo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkSNPangusOrderNo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkSNPangusOrderNo*)p = *(struct __ns1__checkSNPangusOrderNo*)q;
		break;
	case SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SnSaveTechProcess_USCOREA type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SnSaveTechProcess_USCOREA*)p = *(struct __ns1__SnSaveTechProcess_USCOREA*)q;
		break;
	case SOAP_TYPE___ns1__staffCheck:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__staffCheck type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__staffCheck*)p = *(struct __ns1__staffCheck*)q;
		break;
	case SOAP_TYPE___ns1__getAssemblyData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getAssemblyData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getAssemblyData*)p = *(struct __ns1__getAssemblyData*)q;
		break;
	case SOAP_TYPE___ns1__InsertPRateData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsertPRateData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsertPRateData*)p = *(struct __ns1__InsertPRateData*)q;
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData1:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__blakeTestExchangeData1 type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__blakeTestExchangeData1*)p = *(struct __ns1__blakeTestExchangeData1*)q;
		break;
	case SOAP_TYPE___ns1__InsertTimeControl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__InsertTimeControl type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__InsertTimeControl*)p = *(struct __ns1__InsertTimeControl*)q;
		break;
	case SOAP_TYPE___ns1__checkMac:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkMac type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkMac*)p = *(struct __ns1__checkMac*)q;
		break;
	case SOAP_TYPE___ns1__getMaintanceParm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getMaintanceParm type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getMaintanceParm*)p = *(struct __ns1__getMaintanceParm*)q;
		break;
	case SOAP_TYPE___ns1__fetchSnCurrentLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__fetchSnCurrentLocation type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__fetchSnCurrentLocation*)p = *(struct __ns1__fetchSnCurrentLocation*)q;
		break;
	case SOAP_TYPE___ns1__goNewRouteseq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__goNewRouteseq type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__goNewRouteseq*)p = *(struct __ns1__goNewRouteseq*)q;
		break;
	case SOAP_TYPE___ns1__blakeTestExchangeData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__blakeTestExchangeData type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__blakeTestExchangeData*)p = *(struct __ns1__blakeTestExchangeData*)q;
		break;
	case SOAP_TYPE___ns1__checkingSNNextRoute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__checkingSNNextRoute type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__checkingSNNextRoute*)p = *(struct __ns1__checkingSNNextRoute*)q;
		break;
	case SOAP_TYPE___ns1__Ispasspostburnin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Ispasspostburnin type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Ispasspostburnin*)p = *(struct __ns1__Ispasspostburnin*)q;
		break;
	case SOAP_TYPE___ns1__CheckTimeGap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CheckTimeGap type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CheckTimeGap*)p = *(struct __ns1__CheckTimeGap*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckTimeGapResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CheckTimeGapResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__CheckTimeGapResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CheckTimeGapResponse::out);
#endif
}

int _ns1__CheckTimeGapResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckTimeGapResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckTimeGapResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckTimeGapResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckTimeGapResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__CheckTimeGapResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__CheckTimeGapResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckTimeGapResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckTimeGapResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckTimeGapResponse * SOAP_FMAC4 soap_in__ns1__CheckTimeGapResponse(struct soap *soap, const char *tag, _ns1__CheckTimeGapResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckTimeGapResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckTimeGapResponse, sizeof(_ns1__CheckTimeGapResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckTimeGapResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckTimeGapResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__CheckTimeGapResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CheckTimeGapResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckTimeGapResponse, SOAP_TYPE__ns1__CheckTimeGapResponse, sizeof(_ns1__CheckTimeGapResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckTimeGapResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckTimeGapResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckTimeGapResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckTimeGapResponse *p;
	size_t k = sizeof(_ns1__CheckTimeGapResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CheckTimeGapResponse);
		if (p)
			((_ns1__CheckTimeGapResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CheckTimeGapResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CheckTimeGapResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckTimeGapResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CheckTimeGapResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CheckTimeGapResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CheckTimeGapResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckTimeGapResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckTimeGapResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckTimeGapResponse * SOAP_FMAC4 soap_get__ns1__CheckTimeGapResponse(struct soap *soap, _ns1__CheckTimeGapResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckTimeGapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckTimeGap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CheckTimeGap::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__CheckTimeGap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CheckTimeGap::in0);
#endif
}

int _ns1__CheckTimeGap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckTimeGap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckTimeGap(struct soap *soap, const char *tag, int id, const _ns1__CheckTimeGap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckTimeGap), type))
		return soap->error;
	if (!a->_ns1__CheckTimeGap::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__CheckTimeGap::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckTimeGap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckTimeGap(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckTimeGap * SOAP_FMAC4 soap_in__ns1__CheckTimeGap(struct soap *soap, const char *tag, _ns1__CheckTimeGap *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckTimeGap *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckTimeGap, sizeof(_ns1__CheckTimeGap), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CheckTimeGap)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CheckTimeGap *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__CheckTimeGap::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CheckTimeGap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckTimeGap, SOAP_TYPE__ns1__CheckTimeGap, sizeof(_ns1__CheckTimeGap), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CheckTimeGap * SOAP_FMAC2 soap_instantiate__ns1__CheckTimeGap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckTimeGap(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CheckTimeGap *p;
	size_t k = sizeof(_ns1__CheckTimeGap);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CheckTimeGap);
		if (p)
			((_ns1__CheckTimeGap*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CheckTimeGap, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CheckTimeGap*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CheckTimeGap location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CheckTimeGap, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CheckTimeGap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CheckTimeGap", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckTimeGap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckTimeGap(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckTimeGap * SOAP_FMAC4 soap_get__ns1__CheckTimeGap(struct soap *soap, _ns1__CheckTimeGap *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckTimeGap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IspasspostburninResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__IspasspostburninResponse::out);
	/* transient soap skipped */
}

void _ns1__IspasspostburninResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__IspasspostburninResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IspasspostburninResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IspasspostburninResponse(struct soap *soap, const char *tag, int id, const _ns1__IspasspostburninResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IspasspostburninResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:out");
	if (soap_out_int(soap, "ns1:out", -1, &a->_ns1__IspasspostburninResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IspasspostburninResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IspasspostburninResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IspasspostburninResponse * SOAP_FMAC4 soap_in__ns1__IspasspostburninResponse(struct soap *soap, const char *tag, _ns1__IspasspostburninResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IspasspostburninResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IspasspostburninResponse, sizeof(_ns1__IspasspostburninResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IspasspostburninResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IspasspostburninResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:out", &a->_ns1__IspasspostburninResponse::out, "xsd:int"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__IspasspostburninResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IspasspostburninResponse, SOAP_TYPE__ns1__IspasspostburninResponse, sizeof(_ns1__IspasspostburninResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IspasspostburninResponse * SOAP_FMAC2 soap_instantiate__ns1__IspasspostburninResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IspasspostburninResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IspasspostburninResponse *p;
	size_t k = sizeof(_ns1__IspasspostburninResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__IspasspostburninResponse);
		if (p)
			((_ns1__IspasspostburninResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__IspasspostburninResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__IspasspostburninResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IspasspostburninResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__IspasspostburninResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__IspasspostburninResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:IspasspostburninResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IspasspostburninResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IspasspostburninResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IspasspostburninResponse * SOAP_FMAC4 soap_get__ns1__IspasspostburninResponse(struct soap *soap, _ns1__IspasspostburninResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IspasspostburninResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Ispasspostburnin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Ispasspostburnin::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__Ispasspostburnin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Ispasspostburnin::in0);
#endif
}

int _ns1__Ispasspostburnin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Ispasspostburnin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Ispasspostburnin(struct soap *soap, const char *tag, int id, const _ns1__Ispasspostburnin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Ispasspostburnin), type))
		return soap->error;
	if (!a->_ns1__Ispasspostburnin::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__Ispasspostburnin::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Ispasspostburnin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Ispasspostburnin(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Ispasspostburnin * SOAP_FMAC4 soap_in__ns1__Ispasspostburnin(struct soap *soap, const char *tag, _ns1__Ispasspostburnin *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Ispasspostburnin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Ispasspostburnin, sizeof(_ns1__Ispasspostburnin), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Ispasspostburnin)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Ispasspostburnin *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__Ispasspostburnin::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__Ispasspostburnin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Ispasspostburnin, SOAP_TYPE__ns1__Ispasspostburnin, sizeof(_ns1__Ispasspostburnin), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Ispasspostburnin * SOAP_FMAC2 soap_instantiate__ns1__Ispasspostburnin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Ispasspostburnin(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Ispasspostburnin *p;
	size_t k = sizeof(_ns1__Ispasspostburnin);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Ispasspostburnin);
		if (p)
			((_ns1__Ispasspostburnin*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Ispasspostburnin, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Ispasspostburnin*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Ispasspostburnin location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__Ispasspostburnin, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Ispasspostburnin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Ispasspostburnin", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Ispasspostburnin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Ispasspostburnin(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Ispasspostburnin * SOAP_FMAC4 soap_get__ns1__Ispasspostburnin(struct soap *soap, _ns1__Ispasspostburnin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Ispasspostburnin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkingSNNextRouteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkingSNNextRouteResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__checkingSNNextRouteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkingSNNextRouteResponse::out);
#endif
}

int _ns1__checkingSNNextRouteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkingSNNextRouteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkingSNNextRouteResponse(struct soap *soap, const char *tag, int id, const _ns1__checkingSNNextRouteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkingSNNextRouteResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__checkingSNNextRouteResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__checkingSNNextRouteResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkingSNNextRouteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkingSNNextRouteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkingSNNextRouteResponse * SOAP_FMAC4 soap_in__ns1__checkingSNNextRouteResponse(struct soap *soap, const char *tag, _ns1__checkingSNNextRouteResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkingSNNextRouteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkingSNNextRouteResponse, sizeof(_ns1__checkingSNNextRouteResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkingSNNextRouteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkingSNNextRouteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__checkingSNNextRouteResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkingSNNextRouteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkingSNNextRouteResponse, SOAP_TYPE__ns1__checkingSNNextRouteResponse, sizeof(_ns1__checkingSNNextRouteResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkingSNNextRouteResponse * SOAP_FMAC2 soap_instantiate__ns1__checkingSNNextRouteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkingSNNextRouteResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkingSNNextRouteResponse *p;
	size_t k = sizeof(_ns1__checkingSNNextRouteResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkingSNNextRouteResponse);
		if (p)
			((_ns1__checkingSNNextRouteResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkingSNNextRouteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkingSNNextRouteResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkingSNNextRouteResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkingSNNextRouteResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkingSNNextRouteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkingSNNextRouteResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkingSNNextRouteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkingSNNextRouteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkingSNNextRouteResponse * SOAP_FMAC4 soap_get__ns1__checkingSNNextRouteResponse(struct soap *soap, _ns1__checkingSNNextRouteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkingSNNextRouteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkingSNNextRoute::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkingSNNextRoute::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__checkingSNNextRoute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkingSNNextRoute::in0);
#endif
}

int _ns1__checkingSNNextRoute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkingSNNextRoute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkingSNNextRoute(struct soap *soap, const char *tag, int id, const _ns1__checkingSNNextRoute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkingSNNextRoute), type))
		return soap->error;
	if (!a->_ns1__checkingSNNextRoute::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__checkingSNNextRoute::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkingSNNextRoute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkingSNNextRoute(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkingSNNextRoute * SOAP_FMAC4 soap_in__ns1__checkingSNNextRoute(struct soap *soap, const char *tag, _ns1__checkingSNNextRoute *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkingSNNextRoute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkingSNNextRoute, sizeof(_ns1__checkingSNNextRoute), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkingSNNextRoute)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkingSNNextRoute *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__checkingSNNextRoute::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkingSNNextRoute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkingSNNextRoute, SOAP_TYPE__ns1__checkingSNNextRoute, sizeof(_ns1__checkingSNNextRoute), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkingSNNextRoute * SOAP_FMAC2 soap_instantiate__ns1__checkingSNNextRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkingSNNextRoute(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkingSNNextRoute *p;
	size_t k = sizeof(_ns1__checkingSNNextRoute);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkingSNNextRoute);
		if (p)
			((_ns1__checkingSNNextRoute*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkingSNNextRoute, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkingSNNextRoute*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkingSNNextRoute location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkingSNNextRoute, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkingSNNextRoute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkingSNNextRoute", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkingSNNextRoute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkingSNNextRoute(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkingSNNextRoute * SOAP_FMAC4 soap_get__ns1__checkingSNNextRoute(struct soap *soap, _ns1__checkingSNNextRoute *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkingSNNextRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__blakeTestExchangeDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__blakeTestExchangeDataResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__blakeTestExchangeDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeDataResponse::out);
#endif
}

int _ns1__blakeTestExchangeDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__blakeTestExchangeDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__blakeTestExchangeDataResponse(struct soap *soap, const char *tag, int id, const _ns1__blakeTestExchangeDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__blakeTestExchangeDataResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__blakeTestExchangeDataResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__blakeTestExchangeDataResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__blakeTestExchangeDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__blakeTestExchangeDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeDataResponse * SOAP_FMAC4 soap_in__ns1__blakeTestExchangeDataResponse(struct soap *soap, const char *tag, _ns1__blakeTestExchangeDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__blakeTestExchangeDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__blakeTestExchangeDataResponse, sizeof(_ns1__blakeTestExchangeDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__blakeTestExchangeDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__blakeTestExchangeDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__blakeTestExchangeDataResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__blakeTestExchangeDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__blakeTestExchangeDataResponse, SOAP_TYPE__ns1__blakeTestExchangeDataResponse, sizeof(_ns1__blakeTestExchangeDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__blakeTestExchangeDataResponse * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__blakeTestExchangeDataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__blakeTestExchangeDataResponse *p;
	size_t k = sizeof(_ns1__blakeTestExchangeDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__blakeTestExchangeDataResponse);
		if (p)
			((_ns1__blakeTestExchangeDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__blakeTestExchangeDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__blakeTestExchangeDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__blakeTestExchangeDataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__blakeTestExchangeDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__blakeTestExchangeDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:blakeTestExchangeDataResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__blakeTestExchangeDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__blakeTestExchangeDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeDataResponse * SOAP_FMAC4 soap_get__ns1__blakeTestExchangeDataResponse(struct soap *soap, _ns1__blakeTestExchangeDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__blakeTestExchangeDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__blakeTestExchangeData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__blakeTestExchangeData::in0 = NULL;
	this->_ns1__blakeTestExchangeData::in1 = NULL;
	this->_ns1__blakeTestExchangeData::in2 = NULL;
	/* transient soap skipped */
}

void _ns1__blakeTestExchangeData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData::in2);
#endif
}

int _ns1__blakeTestExchangeData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__blakeTestExchangeData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__blakeTestExchangeData(struct soap *soap, const char *tag, int id, const _ns1__blakeTestExchangeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__blakeTestExchangeData), type))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__blakeTestExchangeData::in0, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__blakeTestExchangeData::in1, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__blakeTestExchangeData::in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__blakeTestExchangeData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__blakeTestExchangeData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData * SOAP_FMAC4 soap_in__ns1__blakeTestExchangeData(struct soap *soap, const char *tag, _ns1__blakeTestExchangeData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__blakeTestExchangeData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__blakeTestExchangeData, sizeof(_ns1__blakeTestExchangeData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__blakeTestExchangeData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__blakeTestExchangeData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__blakeTestExchangeData::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__blakeTestExchangeData::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__blakeTestExchangeData::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__blakeTestExchangeData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__blakeTestExchangeData, SOAP_TYPE__ns1__blakeTestExchangeData, sizeof(_ns1__blakeTestExchangeData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__blakeTestExchangeData * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__blakeTestExchangeData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__blakeTestExchangeData *p;
	size_t k = sizeof(_ns1__blakeTestExchangeData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__blakeTestExchangeData);
		if (p)
			((_ns1__blakeTestExchangeData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__blakeTestExchangeData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__blakeTestExchangeData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__blakeTestExchangeData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__blakeTestExchangeData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__blakeTestExchangeData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:blakeTestExchangeData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__blakeTestExchangeData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__blakeTestExchangeData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData * SOAP_FMAC4 soap_get__ns1__blakeTestExchangeData(struct soap *soap, _ns1__blakeTestExchangeData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__blakeTestExchangeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__goNewRouteseqResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__goNewRouteseqResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__goNewRouteseqResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__goNewRouteseqResponse::out);
#endif
}

int _ns1__goNewRouteseqResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__goNewRouteseqResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__goNewRouteseqResponse(struct soap *soap, const char *tag, int id, const _ns1__goNewRouteseqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__goNewRouteseqResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__goNewRouteseqResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__goNewRouteseqResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__goNewRouteseqResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__goNewRouteseqResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__goNewRouteseqResponse * SOAP_FMAC4 soap_in__ns1__goNewRouteseqResponse(struct soap *soap, const char *tag, _ns1__goNewRouteseqResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__goNewRouteseqResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__goNewRouteseqResponse, sizeof(_ns1__goNewRouteseqResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__goNewRouteseqResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__goNewRouteseqResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__goNewRouteseqResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__goNewRouteseqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__goNewRouteseqResponse, SOAP_TYPE__ns1__goNewRouteseqResponse, sizeof(_ns1__goNewRouteseqResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__goNewRouteseqResponse * SOAP_FMAC2 soap_instantiate__ns1__goNewRouteseqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__goNewRouteseqResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__goNewRouteseqResponse *p;
	size_t k = sizeof(_ns1__goNewRouteseqResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__goNewRouteseqResponse);
		if (p)
			((_ns1__goNewRouteseqResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__goNewRouteseqResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__goNewRouteseqResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__goNewRouteseqResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__goNewRouteseqResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__goNewRouteseqResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:goNewRouteseqResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__goNewRouteseqResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__goNewRouteseqResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__goNewRouteseqResponse * SOAP_FMAC4 soap_get__ns1__goNewRouteseqResponse(struct soap *soap, _ns1__goNewRouteseqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__goNewRouteseqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__goNewRouteseq::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__goNewRouteseq::in0 = NULL;
	this->_ns1__goNewRouteseq::in1 = NULL;
	this->_ns1__goNewRouteseq::in2 = NULL;
	/* transient soap skipped */
}

void _ns1__goNewRouteseq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__goNewRouteseq::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__goNewRouteseq::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__goNewRouteseq::in2);
#endif
}

int _ns1__goNewRouteseq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__goNewRouteseq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__goNewRouteseq(struct soap *soap, const char *tag, int id, const _ns1__goNewRouteseq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__goNewRouteseq), type))
		return soap->error;
	if (!a->_ns1__goNewRouteseq::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__goNewRouteseq::in0, ""))
		return soap->error;
	if (!a->_ns1__goNewRouteseq::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__goNewRouteseq::in1, ""))
		return soap->error;
	if (!a->_ns1__goNewRouteseq::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__goNewRouteseq::in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__goNewRouteseq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__goNewRouteseq(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__goNewRouteseq * SOAP_FMAC4 soap_in__ns1__goNewRouteseq(struct soap *soap, const char *tag, _ns1__goNewRouteseq *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__goNewRouteseq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__goNewRouteseq, sizeof(_ns1__goNewRouteseq), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__goNewRouteseq)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__goNewRouteseq *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__goNewRouteseq::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__goNewRouteseq::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__goNewRouteseq::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__goNewRouteseq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__goNewRouteseq, SOAP_TYPE__ns1__goNewRouteseq, sizeof(_ns1__goNewRouteseq), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__goNewRouteseq * SOAP_FMAC2 soap_instantiate__ns1__goNewRouteseq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__goNewRouteseq(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__goNewRouteseq *p;
	size_t k = sizeof(_ns1__goNewRouteseq);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__goNewRouteseq);
		if (p)
			((_ns1__goNewRouteseq*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__goNewRouteseq, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__goNewRouteseq*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__goNewRouteseq location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__goNewRouteseq, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__goNewRouteseq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:goNewRouteseq", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__goNewRouteseq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__goNewRouteseq(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__goNewRouteseq * SOAP_FMAC4 soap_get__ns1__goNewRouteseq(struct soap *soap, _ns1__goNewRouteseq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__goNewRouteseq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__fetchSnCurrentLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__fetchSnCurrentLocationResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__fetchSnCurrentLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__fetchSnCurrentLocationResponse::out);
#endif
}

int _ns1__fetchSnCurrentLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__fetchSnCurrentLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__fetchSnCurrentLocationResponse(struct soap *soap, const char *tag, int id, const _ns1__fetchSnCurrentLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__fetchSnCurrentLocationResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__fetchSnCurrentLocationResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__fetchSnCurrentLocationResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__fetchSnCurrentLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__fetchSnCurrentLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocationResponse * SOAP_FMAC4 soap_in__ns1__fetchSnCurrentLocationResponse(struct soap *soap, const char *tag, _ns1__fetchSnCurrentLocationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__fetchSnCurrentLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__fetchSnCurrentLocationResponse, sizeof(_ns1__fetchSnCurrentLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__fetchSnCurrentLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__fetchSnCurrentLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__fetchSnCurrentLocationResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__fetchSnCurrentLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__fetchSnCurrentLocationResponse, SOAP_TYPE__ns1__fetchSnCurrentLocationResponse, sizeof(_ns1__fetchSnCurrentLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__fetchSnCurrentLocationResponse * SOAP_FMAC2 soap_instantiate__ns1__fetchSnCurrentLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__fetchSnCurrentLocationResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__fetchSnCurrentLocationResponse *p;
	size_t k = sizeof(_ns1__fetchSnCurrentLocationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__fetchSnCurrentLocationResponse);
		if (p)
			((_ns1__fetchSnCurrentLocationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__fetchSnCurrentLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__fetchSnCurrentLocationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__fetchSnCurrentLocationResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__fetchSnCurrentLocationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__fetchSnCurrentLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:fetchSnCurrentLocationResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__fetchSnCurrentLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__fetchSnCurrentLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocationResponse * SOAP_FMAC4 soap_get__ns1__fetchSnCurrentLocationResponse(struct soap *soap, _ns1__fetchSnCurrentLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__fetchSnCurrentLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__fetchSnCurrentLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__fetchSnCurrentLocation::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__fetchSnCurrentLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__fetchSnCurrentLocation::in0);
#endif
}

int _ns1__fetchSnCurrentLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__fetchSnCurrentLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, int id, const _ns1__fetchSnCurrentLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__fetchSnCurrentLocation), type))
		return soap->error;
	if (!a->_ns1__fetchSnCurrentLocation::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__fetchSnCurrentLocation::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__fetchSnCurrentLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__fetchSnCurrentLocation(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocation * SOAP_FMAC4 soap_in__ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, _ns1__fetchSnCurrentLocation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__fetchSnCurrentLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__fetchSnCurrentLocation, sizeof(_ns1__fetchSnCurrentLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__fetchSnCurrentLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__fetchSnCurrentLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__fetchSnCurrentLocation::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__fetchSnCurrentLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__fetchSnCurrentLocation, SOAP_TYPE__ns1__fetchSnCurrentLocation, sizeof(_ns1__fetchSnCurrentLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__fetchSnCurrentLocation * SOAP_FMAC2 soap_instantiate__ns1__fetchSnCurrentLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__fetchSnCurrentLocation(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__fetchSnCurrentLocation *p;
	size_t k = sizeof(_ns1__fetchSnCurrentLocation);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__fetchSnCurrentLocation);
		if (p)
			((_ns1__fetchSnCurrentLocation*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__fetchSnCurrentLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__fetchSnCurrentLocation*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__fetchSnCurrentLocation location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__fetchSnCurrentLocation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__fetchSnCurrentLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:fetchSnCurrentLocation", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__fetchSnCurrentLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__fetchSnCurrentLocation(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocation * SOAP_FMAC4 soap_get__ns1__fetchSnCurrentLocation(struct soap *soap, _ns1__fetchSnCurrentLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__fetchSnCurrentLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMaintanceParmResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMaintanceParmResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getMaintanceParmResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMaintanceParmResponse::out);
#endif
}

int _ns1__getMaintanceParmResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMaintanceParmResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMaintanceParmResponse(struct soap *soap, const char *tag, int id, const _ns1__getMaintanceParmResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMaintanceParmResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__getMaintanceParmResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__getMaintanceParmResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMaintanceParmResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMaintanceParmResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMaintanceParmResponse * SOAP_FMAC4 soap_in__ns1__getMaintanceParmResponse(struct soap *soap, const char *tag, _ns1__getMaintanceParmResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMaintanceParmResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMaintanceParmResponse, sizeof(_ns1__getMaintanceParmResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMaintanceParmResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMaintanceParmResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__getMaintanceParmResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getMaintanceParmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMaintanceParmResponse, SOAP_TYPE__ns1__getMaintanceParmResponse, sizeof(_ns1__getMaintanceParmResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMaintanceParmResponse * SOAP_FMAC2 soap_instantiate__ns1__getMaintanceParmResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMaintanceParmResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMaintanceParmResponse *p;
	size_t k = sizeof(_ns1__getMaintanceParmResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMaintanceParmResponse);
		if (p)
			((_ns1__getMaintanceParmResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMaintanceParmResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMaintanceParmResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMaintanceParmResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMaintanceParmResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMaintanceParmResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getMaintanceParmResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMaintanceParmResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMaintanceParmResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMaintanceParmResponse * SOAP_FMAC4 soap_get__ns1__getMaintanceParmResponse(struct soap *soap, _ns1__getMaintanceParmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMaintanceParmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getMaintanceParm::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getMaintanceParm::in0 = NULL;
	this->_ns1__getMaintanceParm::in1 = NULL;
	this->_ns1__getMaintanceParm::in2 = NULL;
	/* transient soap skipped */
}

void _ns1__getMaintanceParm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMaintanceParm::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMaintanceParm::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getMaintanceParm::in2);
#endif
}

int _ns1__getMaintanceParm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getMaintanceParm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getMaintanceParm(struct soap *soap, const char *tag, int id, const _ns1__getMaintanceParm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getMaintanceParm), type))
		return soap->error;
	if (!a->_ns1__getMaintanceParm::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__getMaintanceParm::in0, ""))
		return soap->error;
	if (!a->_ns1__getMaintanceParm::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__getMaintanceParm::in1, ""))
		return soap->error;
	if (!a->_ns1__getMaintanceParm::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__getMaintanceParm::in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getMaintanceParm::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getMaintanceParm(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getMaintanceParm * SOAP_FMAC4 soap_in__ns1__getMaintanceParm(struct soap *soap, const char *tag, _ns1__getMaintanceParm *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getMaintanceParm *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getMaintanceParm, sizeof(_ns1__getMaintanceParm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getMaintanceParm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getMaintanceParm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__getMaintanceParm::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__getMaintanceParm::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__getMaintanceParm::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getMaintanceParm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getMaintanceParm, SOAP_TYPE__ns1__getMaintanceParm, sizeof(_ns1__getMaintanceParm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getMaintanceParm * SOAP_FMAC2 soap_instantiate__ns1__getMaintanceParm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getMaintanceParm(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getMaintanceParm *p;
	size_t k = sizeof(_ns1__getMaintanceParm);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getMaintanceParm);
		if (p)
			((_ns1__getMaintanceParm*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getMaintanceParm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getMaintanceParm*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getMaintanceParm location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getMaintanceParm, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getMaintanceParm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getMaintanceParm", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getMaintanceParm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getMaintanceParm(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getMaintanceParm * SOAP_FMAC4 soap_get__ns1__getMaintanceParm(struct soap *soap, _ns1__getMaintanceParm *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getMaintanceParm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkMacResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkMacResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__checkMacResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkMacResponse::out);
#endif
}

int _ns1__checkMacResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkMacResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkMacResponse(struct soap *soap, const char *tag, int id, const _ns1__checkMacResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkMacResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__checkMacResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__checkMacResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkMacResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkMacResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkMacResponse * SOAP_FMAC4 soap_in__ns1__checkMacResponse(struct soap *soap, const char *tag, _ns1__checkMacResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkMacResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkMacResponse, sizeof(_ns1__checkMacResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkMacResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkMacResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__checkMacResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkMacResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkMacResponse, SOAP_TYPE__ns1__checkMacResponse, sizeof(_ns1__checkMacResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkMacResponse * SOAP_FMAC2 soap_instantiate__ns1__checkMacResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkMacResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkMacResponse *p;
	size_t k = sizeof(_ns1__checkMacResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkMacResponse);
		if (p)
			((_ns1__checkMacResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkMacResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkMacResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkMacResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkMacResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkMacResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkMacResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkMacResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkMacResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkMacResponse * SOAP_FMAC4 soap_get__ns1__checkMacResponse(struct soap *soap, _ns1__checkMacResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkMacResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkMac::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkMac::in0 = NULL;
	this->_ns1__checkMac::in1 = NULL;
	/* transient soap skipped */
}

void _ns1__checkMac::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkMac::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkMac::in1);
#endif
}

int _ns1__checkMac::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkMac(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkMac(struct soap *soap, const char *tag, int id, const _ns1__checkMac *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkMac), type))
		return soap->error;
	if (!a->_ns1__checkMac::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__checkMac::in0, ""))
		return soap->error;
	if (!a->_ns1__checkMac::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__checkMac::in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkMac::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkMac(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkMac * SOAP_FMAC4 soap_in__ns1__checkMac(struct soap *soap, const char *tag, _ns1__checkMac *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkMac *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkMac, sizeof(_ns1__checkMac), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkMac)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkMac *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__checkMac::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__checkMac::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkMac *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkMac, SOAP_TYPE__ns1__checkMac, sizeof(_ns1__checkMac), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkMac * SOAP_FMAC2 soap_instantiate__ns1__checkMac(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkMac(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkMac *p;
	size_t k = sizeof(_ns1__checkMac);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkMac);
		if (p)
			((_ns1__checkMac*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkMac, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkMac*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkMac location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkMac, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkMac::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkMac", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkMac::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkMac(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkMac * SOAP_FMAC4 soap_get__ns1__checkMac(struct soap *soap, _ns1__checkMac *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkMac(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsertTimeControlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsertTimeControlResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__InsertTimeControlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControlResponse::out);
#endif
}

int _ns1__InsertTimeControlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertTimeControlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertTimeControlResponse(struct soap *soap, const char *tag, int id, const _ns1__InsertTimeControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertTimeControlResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__InsertTimeControlResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__InsertTimeControlResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertTimeControlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertTimeControlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertTimeControlResponse * SOAP_FMAC4 soap_in__ns1__InsertTimeControlResponse(struct soap *soap, const char *tag, _ns1__InsertTimeControlResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertTimeControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertTimeControlResponse, sizeof(_ns1__InsertTimeControlResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsertTimeControlResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsertTimeControlResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__InsertTimeControlResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InsertTimeControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertTimeControlResponse, SOAP_TYPE__ns1__InsertTimeControlResponse, sizeof(_ns1__InsertTimeControlResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsertTimeControlResponse * SOAP_FMAC2 soap_instantiate__ns1__InsertTimeControlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertTimeControlResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsertTimeControlResponse *p;
	size_t k = sizeof(_ns1__InsertTimeControlResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsertTimeControlResponse);
		if (p)
			((_ns1__InsertTimeControlResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsertTimeControlResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsertTimeControlResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsertTimeControlResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsertTimeControlResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsertTimeControlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InsertTimeControlResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertTimeControlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertTimeControlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertTimeControlResponse * SOAP_FMAC4 soap_get__ns1__InsertTimeControlResponse(struct soap *soap, _ns1__InsertTimeControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertTimeControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsertTimeControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsertTimeControl::in0 = NULL;
	this->_ns1__InsertTimeControl::in1 = NULL;
	this->_ns1__InsertTimeControl::in2 = NULL;
	this->_ns1__InsertTimeControl::in3 = NULL;
	this->_ns1__InsertTimeControl::in4 = NULL;
	this->_ns1__InsertTimeControl::in5 = NULL;
	/* transient soap skipped */
}

void _ns1__InsertTimeControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertTimeControl::in5);
#endif
}

int _ns1__InsertTimeControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertTimeControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertTimeControl(struct soap *soap, const char *tag, int id, const _ns1__InsertTimeControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertTimeControl), type))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__InsertTimeControl::in0, ""))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__InsertTimeControl::in1, ""))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__InsertTimeControl::in2, ""))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in3)
	{	if (soap_element_nil(soap, "ns1:in3"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in3", -1, &a->_ns1__InsertTimeControl::in3, ""))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in4)
	{	if (soap_element_nil(soap, "ns1:in4"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in4", -1, &a->_ns1__InsertTimeControl::in4, ""))
		return soap->error;
	if (!a->_ns1__InsertTimeControl::in5)
	{	if (soap_element_nil(soap, "ns1:in5"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in5", -1, &a->_ns1__InsertTimeControl::in5, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertTimeControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertTimeControl(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertTimeControl * SOAP_FMAC4 soap_in__ns1__InsertTimeControl(struct soap *soap, const char *tag, _ns1__InsertTimeControl *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertTimeControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertTimeControl, sizeof(_ns1__InsertTimeControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsertTimeControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsertTimeControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	size_t soap_flag_in31 = 1;
	size_t soap_flag_in41 = 1;
	size_t soap_flag_in51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__InsertTimeControl::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__InsertTimeControl::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__InsertTimeControl::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap_flag_in31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in3", &a->_ns1__InsertTimeControl::in3, "xsd:string"))
				{	soap_flag_in31--;
					continue;
				}
			if (soap_flag_in41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in4", &a->_ns1__InsertTimeControl::in4, "xsd:string"))
				{	soap_flag_in41--;
					continue;
				}
			if (soap_flag_in51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in5", &a->_ns1__InsertTimeControl::in5, "xsd:string"))
				{	soap_flag_in51--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0 || soap_flag_in31 > 0 || soap_flag_in41 > 0 || soap_flag_in51 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InsertTimeControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertTimeControl, SOAP_TYPE__ns1__InsertTimeControl, sizeof(_ns1__InsertTimeControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsertTimeControl * SOAP_FMAC2 soap_instantiate__ns1__InsertTimeControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertTimeControl(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsertTimeControl *p;
	size_t k = sizeof(_ns1__InsertTimeControl);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsertTimeControl);
		if (p)
			((_ns1__InsertTimeControl*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsertTimeControl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsertTimeControl*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsertTimeControl location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsertTimeControl, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsertTimeControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InsertTimeControl", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertTimeControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertTimeControl(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertTimeControl * SOAP_FMAC4 soap_get__ns1__InsertTimeControl(struct soap *soap, _ns1__InsertTimeControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertTimeControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__blakeTestExchangeData1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__blakeTestExchangeData1Response::out = NULL;
	/* transient soap skipped */
}

void _ns1__blakeTestExchangeData1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1Response::out);
#endif
}

int _ns1__blakeTestExchangeData1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__blakeTestExchangeData1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__blakeTestExchangeData1Response(struct soap *soap, const char *tag, int id, const _ns1__blakeTestExchangeData1Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__blakeTestExchangeData1Response), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__blakeTestExchangeData1Response::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__blakeTestExchangeData1Response::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__blakeTestExchangeData1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__blakeTestExchangeData1Response(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1Response * SOAP_FMAC4 soap_in__ns1__blakeTestExchangeData1Response(struct soap *soap, const char *tag, _ns1__blakeTestExchangeData1Response *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__blakeTestExchangeData1Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__blakeTestExchangeData1Response, sizeof(_ns1__blakeTestExchangeData1Response), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__blakeTestExchangeData1Response)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__blakeTestExchangeData1Response *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__blakeTestExchangeData1Response::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__blakeTestExchangeData1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__blakeTestExchangeData1Response, SOAP_TYPE__ns1__blakeTestExchangeData1Response, sizeof(_ns1__blakeTestExchangeData1Response), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__blakeTestExchangeData1Response * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__blakeTestExchangeData1Response(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__blakeTestExchangeData1Response *p;
	size_t k = sizeof(_ns1__blakeTestExchangeData1Response);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__blakeTestExchangeData1Response);
		if (p)
			((_ns1__blakeTestExchangeData1Response*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__blakeTestExchangeData1Response, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__blakeTestExchangeData1Response*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__blakeTestExchangeData1Response location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__blakeTestExchangeData1Response, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__blakeTestExchangeData1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:blakeTestExchangeData1Response", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__blakeTestExchangeData1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__blakeTestExchangeData1Response(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1Response * SOAP_FMAC4 soap_get__ns1__blakeTestExchangeData1Response(struct soap *soap, _ns1__blakeTestExchangeData1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__blakeTestExchangeData1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__blakeTestExchangeData1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__blakeTestExchangeData1::in0 = NULL;
	this->_ns1__blakeTestExchangeData1::in1 = NULL;
	this->_ns1__blakeTestExchangeData1::in2 = NULL;
	this->_ns1__blakeTestExchangeData1::in3 = NULL;
	this->_ns1__blakeTestExchangeData1::in4 = NULL;
	/* transient soap skipped */
}

void _ns1__blakeTestExchangeData1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1::in2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1::in3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__blakeTestExchangeData1::in4);
#endif
}

int _ns1__blakeTestExchangeData1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__blakeTestExchangeData1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, int id, const _ns1__blakeTestExchangeData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__blakeTestExchangeData1), type))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData1::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__blakeTestExchangeData1::in0, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData1::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__blakeTestExchangeData1::in1, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData1::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__blakeTestExchangeData1::in2, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData1::in3)
	{	if (soap_element_nil(soap, "ns1:in3"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in3", -1, &a->_ns1__blakeTestExchangeData1::in3, ""))
		return soap->error;
	if (!a->_ns1__blakeTestExchangeData1::in4)
	{	if (soap_element_nil(soap, "ns1:in4"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in4", -1, &a->_ns1__blakeTestExchangeData1::in4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__blakeTestExchangeData1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__blakeTestExchangeData1(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1 * SOAP_FMAC4 soap_in__ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, _ns1__blakeTestExchangeData1 *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__blakeTestExchangeData1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__blakeTestExchangeData1, sizeof(_ns1__blakeTestExchangeData1), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__blakeTestExchangeData1)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__blakeTestExchangeData1 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	size_t soap_flag_in31 = 1;
	size_t soap_flag_in41 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__blakeTestExchangeData1::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__blakeTestExchangeData1::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__blakeTestExchangeData1::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap_flag_in31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in3", &a->_ns1__blakeTestExchangeData1::in3, "xsd:string"))
				{	soap_flag_in31--;
					continue;
				}
			if (soap_flag_in41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in4", &a->_ns1__blakeTestExchangeData1::in4, "xsd:string"))
				{	soap_flag_in41--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0 || soap_flag_in31 > 0 || soap_flag_in41 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__blakeTestExchangeData1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__blakeTestExchangeData1, SOAP_TYPE__ns1__blakeTestExchangeData1, sizeof(_ns1__blakeTestExchangeData1), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__blakeTestExchangeData1 * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__blakeTestExchangeData1(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__blakeTestExchangeData1 *p;
	size_t k = sizeof(_ns1__blakeTestExchangeData1);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__blakeTestExchangeData1);
		if (p)
			((_ns1__blakeTestExchangeData1*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__blakeTestExchangeData1, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__blakeTestExchangeData1*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__blakeTestExchangeData1 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__blakeTestExchangeData1, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__blakeTestExchangeData1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:blakeTestExchangeData1", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__blakeTestExchangeData1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__blakeTestExchangeData1(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1 * SOAP_FMAC4 soap_get__ns1__blakeTestExchangeData1(struct soap *soap, _ns1__blakeTestExchangeData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__blakeTestExchangeData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsertPRateDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsertPRateDataResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__InsertPRateDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateDataResponse::out);
#endif
}

int _ns1__InsertPRateDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertPRateDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertPRateDataResponse(struct soap *soap, const char *tag, int id, const _ns1__InsertPRateDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertPRateDataResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__InsertPRateDataResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__InsertPRateDataResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertPRateDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertPRateDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertPRateDataResponse * SOAP_FMAC4 soap_in__ns1__InsertPRateDataResponse(struct soap *soap, const char *tag, _ns1__InsertPRateDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertPRateDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertPRateDataResponse, sizeof(_ns1__InsertPRateDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsertPRateDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsertPRateDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__InsertPRateDataResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InsertPRateDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertPRateDataResponse, SOAP_TYPE__ns1__InsertPRateDataResponse, sizeof(_ns1__InsertPRateDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsertPRateDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsertPRateDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertPRateDataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsertPRateDataResponse *p;
	size_t k = sizeof(_ns1__InsertPRateDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsertPRateDataResponse);
		if (p)
			((_ns1__InsertPRateDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsertPRateDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsertPRateDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsertPRateDataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsertPRateDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsertPRateDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InsertPRateDataResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertPRateDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertPRateDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertPRateDataResponse * SOAP_FMAC4 soap_get__ns1__InsertPRateDataResponse(struct soap *soap, _ns1__InsertPRateDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertPRateDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InsertPRateData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__InsertPRateData::in0 = NULL;
	this->_ns1__InsertPRateData::in1 = NULL;
	this->_ns1__InsertPRateData::in2 = NULL;
	this->_ns1__InsertPRateData::in3 = NULL;
	this->_ns1__InsertPRateData::in4 = NULL;
	this->_ns1__InsertPRateData::in5 = NULL;
	this->_ns1__InsertPRateData::in6 = NULL;
	this->_ns1__InsertPRateData::in7 = NULL;
	this->_ns1__InsertPRateData::in8 = NULL;
	this->_ns1__InsertPRateData::in9 = NULL;
	this->_ns1__InsertPRateData::in10 = NULL;
	/* transient soap skipped */
}

void _ns1__InsertPRateData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in5);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in6);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in7);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in8);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in9);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__InsertPRateData::in10);
#endif
}

int _ns1__InsertPRateData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InsertPRateData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InsertPRateData(struct soap *soap, const char *tag, int id, const _ns1__InsertPRateData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InsertPRateData), type))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__InsertPRateData::in0, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__InsertPRateData::in1, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__InsertPRateData::in2, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in3)
	{	if (soap_element_nil(soap, "ns1:in3"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in3", -1, &a->_ns1__InsertPRateData::in3, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in4)
	{	if (soap_element_nil(soap, "ns1:in4"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in4", -1, &a->_ns1__InsertPRateData::in4, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in5)
	{	if (soap_element_nil(soap, "ns1:in5"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in5", -1, &a->_ns1__InsertPRateData::in5, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in6)
	{	if (soap_element_nil(soap, "ns1:in6"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in6", -1, &a->_ns1__InsertPRateData::in6, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in7)
	{	if (soap_element_nil(soap, "ns1:in7"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in7", -1, &a->_ns1__InsertPRateData::in7, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in8)
	{	if (soap_element_nil(soap, "ns1:in8"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in8", -1, &a->_ns1__InsertPRateData::in8, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in9)
	{	if (soap_element_nil(soap, "ns1:in9"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in9", -1, &a->_ns1__InsertPRateData::in9, ""))
		return soap->error;
	if (!a->_ns1__InsertPRateData::in10)
	{	if (soap_element_nil(soap, "ns1:in10"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in10", -1, &a->_ns1__InsertPRateData::in10, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InsertPRateData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InsertPRateData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InsertPRateData * SOAP_FMAC4 soap_in__ns1__InsertPRateData(struct soap *soap, const char *tag, _ns1__InsertPRateData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InsertPRateData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InsertPRateData, sizeof(_ns1__InsertPRateData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__InsertPRateData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__InsertPRateData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	size_t soap_flag_in31 = 1;
	size_t soap_flag_in41 = 1;
	size_t soap_flag_in51 = 1;
	size_t soap_flag_in61 = 1;
	size_t soap_flag_in71 = 1;
	size_t soap_flag_in81 = 1;
	size_t soap_flag_in91 = 1;
	size_t soap_flag_in101 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__InsertPRateData::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__InsertPRateData::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__InsertPRateData::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap_flag_in31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in3", &a->_ns1__InsertPRateData::in3, "xsd:string"))
				{	soap_flag_in31--;
					continue;
				}
			if (soap_flag_in41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in4", &a->_ns1__InsertPRateData::in4, "xsd:string"))
				{	soap_flag_in41--;
					continue;
				}
			if (soap_flag_in51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in5", &a->_ns1__InsertPRateData::in5, "xsd:string"))
				{	soap_flag_in51--;
					continue;
				}
			if (soap_flag_in61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in6", &a->_ns1__InsertPRateData::in6, "xsd:string"))
				{	soap_flag_in61--;
					continue;
				}
			if (soap_flag_in71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in7", &a->_ns1__InsertPRateData::in7, "xsd:string"))
				{	soap_flag_in71--;
					continue;
				}
			if (soap_flag_in81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in8", &a->_ns1__InsertPRateData::in8, "xsd:string"))
				{	soap_flag_in81--;
					continue;
				}
			if (soap_flag_in91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in9", &a->_ns1__InsertPRateData::in9, "xsd:string"))
				{	soap_flag_in91--;
					continue;
				}
			if (soap_flag_in101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in10", &a->_ns1__InsertPRateData::in10, "xsd:string"))
				{	soap_flag_in101--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0 || soap_flag_in31 > 0 || soap_flag_in41 > 0 || soap_flag_in51 > 0 || soap_flag_in61 > 0 || soap_flag_in71 > 0 || soap_flag_in81 > 0 || soap_flag_in91 > 0 || soap_flag_in101 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InsertPRateData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InsertPRateData, SOAP_TYPE__ns1__InsertPRateData, sizeof(_ns1__InsertPRateData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InsertPRateData * SOAP_FMAC2 soap_instantiate__ns1__InsertPRateData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InsertPRateData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InsertPRateData *p;
	size_t k = sizeof(_ns1__InsertPRateData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InsertPRateData);
		if (p)
			((_ns1__InsertPRateData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InsertPRateData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InsertPRateData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InsertPRateData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InsertPRateData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InsertPRateData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InsertPRateData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InsertPRateData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InsertPRateData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InsertPRateData * SOAP_FMAC4 soap_get__ns1__InsertPRateData(struct soap *soap, _ns1__InsertPRateData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InsertPRateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getAssemblyDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAssemblyDataResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getAssemblyDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getAssemblyDataResponse::out);
#endif
}

int _ns1__getAssemblyDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAssemblyDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAssemblyDataResponse(struct soap *soap, const char *tag, int id, const _ns1__getAssemblyDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAssemblyDataResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__getAssemblyDataResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__getAssemblyDataResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAssemblyDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAssemblyDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAssemblyDataResponse * SOAP_FMAC4 soap_in__ns1__getAssemblyDataResponse(struct soap *soap, const char *tag, _ns1__getAssemblyDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAssemblyDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAssemblyDataResponse, sizeof(_ns1__getAssemblyDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getAssemblyDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getAssemblyDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__getAssemblyDataResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getAssemblyDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAssemblyDataResponse, SOAP_TYPE__ns1__getAssemblyDataResponse, sizeof(_ns1__getAssemblyDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getAssemblyDataResponse * SOAP_FMAC2 soap_instantiate__ns1__getAssemblyDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAssemblyDataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getAssemblyDataResponse *p;
	size_t k = sizeof(_ns1__getAssemblyDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getAssemblyDataResponse);
		if (p)
			((_ns1__getAssemblyDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getAssemblyDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getAssemblyDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getAssemblyDataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getAssemblyDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getAssemblyDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getAssemblyDataResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAssemblyDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAssemblyDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAssemblyDataResponse * SOAP_FMAC4 soap_get__ns1__getAssemblyDataResponse(struct soap *soap, _ns1__getAssemblyDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAssemblyDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getAssemblyData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getAssemblyData::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__getAssemblyData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getAssemblyData::in0);
#endif
}

int _ns1__getAssemblyData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getAssemblyData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAssemblyData(struct soap *soap, const char *tag, int id, const _ns1__getAssemblyData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAssemblyData), type))
		return soap->error;
	if (!a->_ns1__getAssemblyData::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__getAssemblyData::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getAssemblyData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getAssemblyData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getAssemblyData * SOAP_FMAC4 soap_in__ns1__getAssemblyData(struct soap *soap, const char *tag, _ns1__getAssemblyData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getAssemblyData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAssemblyData, sizeof(_ns1__getAssemblyData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__getAssemblyData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__getAssemblyData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__getAssemblyData::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getAssemblyData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAssemblyData, SOAP_TYPE__ns1__getAssemblyData, sizeof(_ns1__getAssemblyData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getAssemblyData * SOAP_FMAC2 soap_instantiate__ns1__getAssemblyData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getAssemblyData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getAssemblyData *p;
	size_t k = sizeof(_ns1__getAssemblyData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getAssemblyData);
		if (p)
			((_ns1__getAssemblyData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getAssemblyData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getAssemblyData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getAssemblyData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getAssemblyData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getAssemblyData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getAssemblyData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getAssemblyData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getAssemblyData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getAssemblyData * SOAP_FMAC4 soap_get__ns1__getAssemblyData(struct soap *soap, _ns1__getAssemblyData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAssemblyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__staffCheckResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__staffCheckResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__staffCheckResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__staffCheckResponse::out);
#endif
}

int _ns1__staffCheckResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__staffCheckResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__staffCheckResponse(struct soap *soap, const char *tag, int id, const _ns1__staffCheckResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__staffCheckResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__staffCheckResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__staffCheckResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__staffCheckResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__staffCheckResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__staffCheckResponse * SOAP_FMAC4 soap_in__ns1__staffCheckResponse(struct soap *soap, const char *tag, _ns1__staffCheckResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__staffCheckResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__staffCheckResponse, sizeof(_ns1__staffCheckResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__staffCheckResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__staffCheckResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__staffCheckResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__staffCheckResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__staffCheckResponse, SOAP_TYPE__ns1__staffCheckResponse, sizeof(_ns1__staffCheckResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__staffCheckResponse * SOAP_FMAC2 soap_instantiate__ns1__staffCheckResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__staffCheckResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__staffCheckResponse *p;
	size_t k = sizeof(_ns1__staffCheckResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__staffCheckResponse);
		if (p)
			((_ns1__staffCheckResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__staffCheckResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__staffCheckResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__staffCheckResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__staffCheckResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__staffCheckResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:staffCheckResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__staffCheckResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__staffCheckResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__staffCheckResponse * SOAP_FMAC4 soap_get__ns1__staffCheckResponse(struct soap *soap, _ns1__staffCheckResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__staffCheckResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__staffCheck::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__staffCheck::in0 = NULL;
	this->_ns1__staffCheck::in1 = NULL;
	/* transient soap skipped */
}

void _ns1__staffCheck::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__staffCheck::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__staffCheck::in1);
#endif
}

int _ns1__staffCheck::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__staffCheck(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__staffCheck(struct soap *soap, const char *tag, int id, const _ns1__staffCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__staffCheck), type))
		return soap->error;
	if (!a->_ns1__staffCheck::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__staffCheck::in0, ""))
		return soap->error;
	if (!a->_ns1__staffCheck::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__staffCheck::in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__staffCheck::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__staffCheck(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__staffCheck * SOAP_FMAC4 soap_in__ns1__staffCheck(struct soap *soap, const char *tag, _ns1__staffCheck *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__staffCheck *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__staffCheck, sizeof(_ns1__staffCheck), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__staffCheck)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__staffCheck *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__staffCheck::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__staffCheck::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__staffCheck *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__staffCheck, SOAP_TYPE__ns1__staffCheck, sizeof(_ns1__staffCheck), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__staffCheck * SOAP_FMAC2 soap_instantiate__ns1__staffCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__staffCheck(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__staffCheck *p;
	size_t k = sizeof(_ns1__staffCheck);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__staffCheck);
		if (p)
			((_ns1__staffCheck*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__staffCheck, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__staffCheck*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__staffCheck location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__staffCheck, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__staffCheck::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:staffCheck", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__staffCheck::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__staffCheck(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__staffCheck * SOAP_FMAC4 soap_get__ns1__staffCheck(struct soap *soap, _ns1__staffCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__staffCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnSaveTechProcess_USCOREAResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnSaveTechProcess_USCOREAResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__SnSaveTechProcess_USCOREAResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREAResponse::out);
#endif
}

int _ns1__SnSaveTechProcess_USCOREAResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnSaveTechProcess_USCOREAResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnSaveTechProcess_USCOREAResponse(struct soap *soap, const char *tag, int id, const _ns1__SnSaveTechProcess_USCOREAResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__SnSaveTechProcess_USCOREAResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__SnSaveTechProcess_USCOREAResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnSaveTechProcess_USCOREAResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnSaveTechProcess_USCOREAResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREAResponse * SOAP_FMAC4 soap_in__ns1__SnSaveTechProcess_USCOREAResponse(struct soap *soap, const char *tag, _ns1__SnSaveTechProcess_USCOREAResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnSaveTechProcess_USCOREAResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse, sizeof(_ns1__SnSaveTechProcess_USCOREAResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnSaveTechProcess_USCOREAResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__SnSaveTechProcess_USCOREAResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SnSaveTechProcess_USCOREAResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse, sizeof(_ns1__SnSaveTechProcess_USCOREAResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnSaveTechProcess_USCOREAResponse * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess_USCOREAResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnSaveTechProcess_USCOREAResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnSaveTechProcess_USCOREAResponse *p;
	size_t k = sizeof(_ns1__SnSaveTechProcess_USCOREAResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnSaveTechProcess_USCOREAResponse);
		if (p)
			((_ns1__SnSaveTechProcess_USCOREAResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnSaveTechProcess_USCOREAResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnSaveTechProcess_USCOREAResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnSaveTechProcess_USCOREAResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnSaveTechProcess_USCOREAResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SnSaveTechProcess_AResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnSaveTechProcess_USCOREAResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnSaveTechProcess_USCOREAResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREAResponse * SOAP_FMAC4 soap_get__ns1__SnSaveTechProcess_USCOREAResponse(struct soap *soap, _ns1__SnSaveTechProcess_USCOREAResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnSaveTechProcess_USCOREAResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnSaveTechProcess_USCOREA::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnSaveTechProcess_USCOREA::in0 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in1 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in2 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in3 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in4 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in5 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in6 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in7 = NULL;
	this->_ns1__SnSaveTechProcess_USCOREA::in8 = NULL;
	/* transient soap skipped */
}

void _ns1__SnSaveTechProcess_USCOREA::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in5);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in6);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in7);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess_USCOREA::in8);
#endif
}

int _ns1__SnSaveTechProcess_USCOREA::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnSaveTechProcess_USCOREA(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, int id, const _ns1__SnSaveTechProcess_USCOREA *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA), type))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in0, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in1, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in2, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in3)
	{	if (soap_element_nil(soap, "ns1:in3"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in3", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in3, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in4)
	{	if (soap_element_nil(soap, "ns1:in4"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in4", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in4, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in5)
	{	if (soap_element_nil(soap, "ns1:in5"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in5", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in5, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in6)
	{	if (soap_element_nil(soap, "ns1:in6"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in6", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in6, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in7)
	{	if (soap_element_nil(soap, "ns1:in7"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in7", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in7, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess_USCOREA::in8)
	{	if (soap_element_nil(soap, "ns1:in8"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in8", -1, &a->_ns1__SnSaveTechProcess_USCOREA::in8, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnSaveTechProcess_USCOREA::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnSaveTechProcess_USCOREA(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC4 soap_in__ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, _ns1__SnSaveTechProcess_USCOREA *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnSaveTechProcess_USCOREA *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, sizeof(_ns1__SnSaveTechProcess_USCOREA), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnSaveTechProcess_USCOREA *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	size_t soap_flag_in31 = 1;
	size_t soap_flag_in41 = 1;
	size_t soap_flag_in51 = 1;
	size_t soap_flag_in61 = 1;
	size_t soap_flag_in71 = 1;
	size_t soap_flag_in81 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__SnSaveTechProcess_USCOREA::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__SnSaveTechProcess_USCOREA::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__SnSaveTechProcess_USCOREA::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap_flag_in31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in3", &a->_ns1__SnSaveTechProcess_USCOREA::in3, "xsd:string"))
				{	soap_flag_in31--;
					continue;
				}
			if (soap_flag_in41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in4", &a->_ns1__SnSaveTechProcess_USCOREA::in4, "xsd:string"))
				{	soap_flag_in41--;
					continue;
				}
			if (soap_flag_in51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in5", &a->_ns1__SnSaveTechProcess_USCOREA::in5, "xsd:string"))
				{	soap_flag_in51--;
					continue;
				}
			if (soap_flag_in61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in6", &a->_ns1__SnSaveTechProcess_USCOREA::in6, "xsd:string"))
				{	soap_flag_in61--;
					continue;
				}
			if (soap_flag_in71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in7", &a->_ns1__SnSaveTechProcess_USCOREA::in7, "xsd:string"))
				{	soap_flag_in71--;
					continue;
				}
			if (soap_flag_in81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in8", &a->_ns1__SnSaveTechProcess_USCOREA::in8, "xsd:string"))
				{	soap_flag_in81--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0 || soap_flag_in31 > 0 || soap_flag_in41 > 0 || soap_flag_in51 > 0 || soap_flag_in61 > 0 || soap_flag_in71 > 0 || soap_flag_in81 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SnSaveTechProcess_USCOREA *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, sizeof(_ns1__SnSaveTechProcess_USCOREA), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess_USCOREA(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnSaveTechProcess_USCOREA(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnSaveTechProcess_USCOREA *p;
	size_t k = sizeof(_ns1__SnSaveTechProcess_USCOREA);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnSaveTechProcess_USCOREA);
		if (p)
			((_ns1__SnSaveTechProcess_USCOREA*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnSaveTechProcess_USCOREA, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnSaveTechProcess_USCOREA*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnSaveTechProcess_USCOREA location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnSaveTechProcess_USCOREA::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SnSaveTechProcess_A", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnSaveTechProcess_USCOREA::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnSaveTechProcess_USCOREA(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC4 soap_get__ns1__SnSaveTechProcess_USCOREA(struct soap *soap, _ns1__SnSaveTechProcess_USCOREA *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnSaveTechProcess_USCOREA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSNPangusOrderNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSNPangusOrderNoResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__checkSNPangusOrderNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSNPangusOrderNoResponse::out);
#endif
}

int _ns1__checkSNPangusOrderNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSNPangusOrderNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSNPangusOrderNoResponse(struct soap *soap, const char *tag, int id, const _ns1__checkSNPangusOrderNoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSNPangusOrderNoResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__checkSNPangusOrderNoResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__checkSNPangusOrderNoResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSNPangusOrderNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSNPangusOrderNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNoResponse * SOAP_FMAC4 soap_in__ns1__checkSNPangusOrderNoResponse(struct soap *soap, const char *tag, _ns1__checkSNPangusOrderNoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSNPangusOrderNoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSNPangusOrderNoResponse, sizeof(_ns1__checkSNPangusOrderNoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSNPangusOrderNoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSNPangusOrderNoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__checkSNPangusOrderNoResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkSNPangusOrderNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSNPangusOrderNoResponse, SOAP_TYPE__ns1__checkSNPangusOrderNoResponse, sizeof(_ns1__checkSNPangusOrderNoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSNPangusOrderNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSNPangusOrderNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSNPangusOrderNoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSNPangusOrderNoResponse *p;
	size_t k = sizeof(_ns1__checkSNPangusOrderNoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSNPangusOrderNoResponse);
		if (p)
			((_ns1__checkSNPangusOrderNoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSNPangusOrderNoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSNPangusOrderNoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSNPangusOrderNoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSNPangusOrderNoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSNPangusOrderNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkSNPangusOrderNoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSNPangusOrderNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSNPangusOrderNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNoResponse * SOAP_FMAC4 soap_get__ns1__checkSNPangusOrderNoResponse(struct soap *soap, _ns1__checkSNPangusOrderNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSNPangusOrderNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSNPangusOrderNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSNPangusOrderNo::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__checkSNPangusOrderNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSNPangusOrderNo::in0);
#endif
}

int _ns1__checkSNPangusOrderNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSNPangusOrderNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, int id, const _ns1__checkSNPangusOrderNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSNPangusOrderNo), type))
		return soap->error;
	if (!a->_ns1__checkSNPangusOrderNo::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__checkSNPangusOrderNo::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSNPangusOrderNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSNPangusOrderNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNo * SOAP_FMAC4 soap_in__ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, _ns1__checkSNPangusOrderNo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSNPangusOrderNo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSNPangusOrderNo, sizeof(_ns1__checkSNPangusOrderNo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSNPangusOrderNo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSNPangusOrderNo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__checkSNPangusOrderNo::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkSNPangusOrderNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSNPangusOrderNo, SOAP_TYPE__ns1__checkSNPangusOrderNo, sizeof(_ns1__checkSNPangusOrderNo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSNPangusOrderNo * SOAP_FMAC2 soap_instantiate__ns1__checkSNPangusOrderNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSNPangusOrderNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSNPangusOrderNo *p;
	size_t k = sizeof(_ns1__checkSNPangusOrderNo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSNPangusOrderNo);
		if (p)
			((_ns1__checkSNPangusOrderNo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSNPangusOrderNo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSNPangusOrderNo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSNPangusOrderNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSNPangusOrderNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSNPangusOrderNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkSNPangusOrderNo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSNPangusOrderNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSNPangusOrderNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNo * SOAP_FMAC4 soap_get__ns1__checkSNPangusOrderNo(struct soap *soap, _ns1__checkSNPangusOrderNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSNPangusOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSNOrderNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSNOrderNoResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__checkSNOrderNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSNOrderNoResponse::out);
#endif
}

int _ns1__checkSNOrderNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSNOrderNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSNOrderNoResponse(struct soap *soap, const char *tag, int id, const _ns1__checkSNOrderNoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSNOrderNoResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__checkSNOrderNoResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__checkSNOrderNoResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSNOrderNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSNOrderNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSNOrderNoResponse * SOAP_FMAC4 soap_in__ns1__checkSNOrderNoResponse(struct soap *soap, const char *tag, _ns1__checkSNOrderNoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSNOrderNoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSNOrderNoResponse, sizeof(_ns1__checkSNOrderNoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSNOrderNoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSNOrderNoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__checkSNOrderNoResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkSNOrderNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSNOrderNoResponse, SOAP_TYPE__ns1__checkSNOrderNoResponse, sizeof(_ns1__checkSNOrderNoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSNOrderNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSNOrderNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSNOrderNoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSNOrderNoResponse *p;
	size_t k = sizeof(_ns1__checkSNOrderNoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSNOrderNoResponse);
		if (p)
			((_ns1__checkSNOrderNoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSNOrderNoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSNOrderNoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSNOrderNoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSNOrderNoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSNOrderNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkSNOrderNoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSNOrderNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSNOrderNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSNOrderNoResponse * SOAP_FMAC4 soap_get__ns1__checkSNOrderNoResponse(struct soap *soap, _ns1__checkSNOrderNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSNOrderNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__checkSNOrderNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__checkSNOrderNo::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__checkSNOrderNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__checkSNOrderNo::in0);
#endif
}

int _ns1__checkSNOrderNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__checkSNOrderNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__checkSNOrderNo(struct soap *soap, const char *tag, int id, const _ns1__checkSNOrderNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__checkSNOrderNo), type))
		return soap->error;
	if (!a->_ns1__checkSNOrderNo::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__checkSNOrderNo::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__checkSNOrderNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__checkSNOrderNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__checkSNOrderNo * SOAP_FMAC4 soap_in__ns1__checkSNOrderNo(struct soap *soap, const char *tag, _ns1__checkSNOrderNo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__checkSNOrderNo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__checkSNOrderNo, sizeof(_ns1__checkSNOrderNo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__checkSNOrderNo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__checkSNOrderNo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__checkSNOrderNo::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__checkSNOrderNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__checkSNOrderNo, SOAP_TYPE__ns1__checkSNOrderNo, sizeof(_ns1__checkSNOrderNo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__checkSNOrderNo * SOAP_FMAC2 soap_instantiate__ns1__checkSNOrderNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__checkSNOrderNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__checkSNOrderNo *p;
	size_t k = sizeof(_ns1__checkSNOrderNo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__checkSNOrderNo);
		if (p)
			((_ns1__checkSNOrderNo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__checkSNOrderNo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__checkSNOrderNo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__checkSNOrderNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__checkSNOrderNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__checkSNOrderNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:checkSNOrderNo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__checkSNOrderNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__checkSNOrderNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__checkSNOrderNo * SOAP_FMAC4 soap_get__ns1__checkSNOrderNo(struct soap *soap, _ns1__checkSNOrderNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__checkSNOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loadNgPanelNoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__loadNgPanelNoResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__loadNgPanelNoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__loadNgPanelNoResponse::out);
#endif
}

int _ns1__loadNgPanelNoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loadNgPanelNoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loadNgPanelNoResponse(struct soap *soap, const char *tag, int id, const _ns1__loadNgPanelNoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loadNgPanelNoResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__loadNgPanelNoResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__loadNgPanelNoResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loadNgPanelNoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loadNgPanelNoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loadNgPanelNoResponse * SOAP_FMAC4 soap_in__ns1__loadNgPanelNoResponse(struct soap *soap, const char *tag, _ns1__loadNgPanelNoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loadNgPanelNoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loadNgPanelNoResponse, sizeof(_ns1__loadNgPanelNoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__loadNgPanelNoResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loadNgPanelNoResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__loadNgPanelNoResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loadNgPanelNoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loadNgPanelNoResponse, SOAP_TYPE__ns1__loadNgPanelNoResponse, sizeof(_ns1__loadNgPanelNoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loadNgPanelNoResponse * SOAP_FMAC2 soap_instantiate__ns1__loadNgPanelNoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loadNgPanelNoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loadNgPanelNoResponse *p;
	size_t k = sizeof(_ns1__loadNgPanelNoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__loadNgPanelNoResponse);
		if (p)
			((_ns1__loadNgPanelNoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__loadNgPanelNoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__loadNgPanelNoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loadNgPanelNoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__loadNgPanelNoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__loadNgPanelNoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:loadNgPanelNoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loadNgPanelNoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loadNgPanelNoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loadNgPanelNoResponse * SOAP_FMAC4 soap_get__ns1__loadNgPanelNoResponse(struct soap *soap, _ns1__loadNgPanelNoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loadNgPanelNoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loadNgPanelNo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__loadNgPanelNo::in0 = NULL;
	/* transient soap skipped */
}

void _ns1__loadNgPanelNo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__loadNgPanelNo::in0);
#endif
}

int _ns1__loadNgPanelNo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loadNgPanelNo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loadNgPanelNo(struct soap *soap, const char *tag, int id, const _ns1__loadNgPanelNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loadNgPanelNo), type))
		return soap->error;
	if (!a->_ns1__loadNgPanelNo::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__loadNgPanelNo::in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loadNgPanelNo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loadNgPanelNo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loadNgPanelNo * SOAP_FMAC4 soap_in__ns1__loadNgPanelNo(struct soap *soap, const char *tag, _ns1__loadNgPanelNo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loadNgPanelNo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loadNgPanelNo, sizeof(_ns1__loadNgPanelNo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__loadNgPanelNo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loadNgPanelNo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__loadNgPanelNo::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loadNgPanelNo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loadNgPanelNo, SOAP_TYPE__ns1__loadNgPanelNo, sizeof(_ns1__loadNgPanelNo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loadNgPanelNo * SOAP_FMAC2 soap_instantiate__ns1__loadNgPanelNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loadNgPanelNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loadNgPanelNo *p;
	size_t k = sizeof(_ns1__loadNgPanelNo);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__loadNgPanelNo);
		if (p)
			((_ns1__loadNgPanelNo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__loadNgPanelNo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__loadNgPanelNo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loadNgPanelNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__loadNgPanelNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__loadNgPanelNo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:loadNgPanelNo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loadNgPanelNo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loadNgPanelNo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loadNgPanelNo * SOAP_FMAC4 soap_get__ns1__loadNgPanelNo(struct soap *soap, _ns1__loadNgPanelNo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loadNgPanelNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loadTimeControlDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__loadTimeControlDataResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__loadTimeControlDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__loadTimeControlDataResponse::out);
#endif
}

int _ns1__loadTimeControlDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loadTimeControlDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loadTimeControlDataResponse(struct soap *soap, const char *tag, int id, const _ns1__loadTimeControlDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loadTimeControlDataResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__loadTimeControlDataResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__loadTimeControlDataResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loadTimeControlDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loadTimeControlDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loadTimeControlDataResponse * SOAP_FMAC4 soap_in__ns1__loadTimeControlDataResponse(struct soap *soap, const char *tag, _ns1__loadTimeControlDataResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loadTimeControlDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loadTimeControlDataResponse, sizeof(_ns1__loadTimeControlDataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__loadTimeControlDataResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loadTimeControlDataResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__loadTimeControlDataResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__loadTimeControlDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loadTimeControlDataResponse, SOAP_TYPE__ns1__loadTimeControlDataResponse, sizeof(_ns1__loadTimeControlDataResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loadTimeControlDataResponse * SOAP_FMAC2 soap_instantiate__ns1__loadTimeControlDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loadTimeControlDataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loadTimeControlDataResponse *p;
	size_t k = sizeof(_ns1__loadTimeControlDataResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__loadTimeControlDataResponse);
		if (p)
			((_ns1__loadTimeControlDataResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__loadTimeControlDataResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__loadTimeControlDataResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loadTimeControlDataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__loadTimeControlDataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__loadTimeControlDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:loadTimeControlDataResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loadTimeControlDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loadTimeControlDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loadTimeControlDataResponse * SOAP_FMAC4 soap_get__ns1__loadTimeControlDataResponse(struct soap *soap, _ns1__loadTimeControlDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loadTimeControlDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__loadTimeControlData::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__loadTimeControlData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__loadTimeControlData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loadTimeControlData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loadTimeControlData(struct soap *soap, const char *tag, int id, const _ns1__loadTimeControlData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loadTimeControlData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__loadTimeControlData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loadTimeControlData(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loadTimeControlData * SOAP_FMAC4 soap_in__ns1__loadTimeControlData(struct soap *soap, const char *tag, _ns1__loadTimeControlData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loadTimeControlData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loadTimeControlData, sizeof(_ns1__loadTimeControlData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__loadTimeControlData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__loadTimeControlData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__loadTimeControlData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loadTimeControlData, SOAP_TYPE__ns1__loadTimeControlData, sizeof(_ns1__loadTimeControlData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__loadTimeControlData * SOAP_FMAC2 soap_instantiate__ns1__loadTimeControlData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loadTimeControlData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__loadTimeControlData *p;
	size_t k = sizeof(_ns1__loadTimeControlData);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__loadTimeControlData);
		if (p)
			((_ns1__loadTimeControlData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__loadTimeControlData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__loadTimeControlData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__loadTimeControlData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__loadTimeControlData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__loadTimeControlData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:loadTimeControlData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__loadTimeControlData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loadTimeControlData(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loadTimeControlData * SOAP_FMAC4 soap_get__ns1__loadTimeControlData(struct soap *soap, _ns1__loadTimeControlData *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loadTimeControlData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__bindAssemblyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__bindAssemblyResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__bindAssemblyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__bindAssemblyResponse::out);
#endif
}

int _ns1__bindAssemblyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__bindAssemblyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__bindAssemblyResponse(struct soap *soap, const char *tag, int id, const _ns1__bindAssemblyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__bindAssemblyResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__bindAssemblyResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__bindAssemblyResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__bindAssemblyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__bindAssemblyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__bindAssemblyResponse * SOAP_FMAC4 soap_in__ns1__bindAssemblyResponse(struct soap *soap, const char *tag, _ns1__bindAssemblyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__bindAssemblyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__bindAssemblyResponse, sizeof(_ns1__bindAssemblyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__bindAssemblyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__bindAssemblyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__bindAssemblyResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__bindAssemblyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__bindAssemblyResponse, SOAP_TYPE__ns1__bindAssemblyResponse, sizeof(_ns1__bindAssemblyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__bindAssemblyResponse * SOAP_FMAC2 soap_instantiate__ns1__bindAssemblyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__bindAssemblyResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__bindAssemblyResponse *p;
	size_t k = sizeof(_ns1__bindAssemblyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__bindAssemblyResponse);
		if (p)
			((_ns1__bindAssemblyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__bindAssemblyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__bindAssemblyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__bindAssemblyResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__bindAssemblyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__bindAssemblyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:bindAssemblyResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__bindAssemblyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__bindAssemblyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__bindAssemblyResponse * SOAP_FMAC4 soap_get__ns1__bindAssemblyResponse(struct soap *soap, _ns1__bindAssemblyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__bindAssemblyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__bindAssembly::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__bindAssembly::in0 = NULL;
	this->_ns1__bindAssembly::in1 = NULL;
	this->_ns1__bindAssembly::in2 = NULL;
	/* transient soap skipped */
}

void _ns1__bindAssembly::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__bindAssembly::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__bindAssembly::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__bindAssembly::in2);
#endif
}

int _ns1__bindAssembly::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__bindAssembly(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__bindAssembly(struct soap *soap, const char *tag, int id, const _ns1__bindAssembly *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__bindAssembly), type))
		return soap->error;
	if (!a->_ns1__bindAssembly::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__bindAssembly::in0, ""))
		return soap->error;
	if (!a->_ns1__bindAssembly::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__bindAssembly::in1, ""))
		return soap->error;
	if (!a->_ns1__bindAssembly::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__bindAssembly::in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__bindAssembly::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__bindAssembly(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__bindAssembly * SOAP_FMAC4 soap_in__ns1__bindAssembly(struct soap *soap, const char *tag, _ns1__bindAssembly *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__bindAssembly *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__bindAssembly, sizeof(_ns1__bindAssembly), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__bindAssembly)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__bindAssembly *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__bindAssembly::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__bindAssembly::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__bindAssembly::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__bindAssembly *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__bindAssembly, SOAP_TYPE__ns1__bindAssembly, sizeof(_ns1__bindAssembly), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__bindAssembly * SOAP_FMAC2 soap_instantiate__ns1__bindAssembly(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__bindAssembly(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__bindAssembly *p;
	size_t k = sizeof(_ns1__bindAssembly);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__bindAssembly);
		if (p)
			((_ns1__bindAssembly*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__bindAssembly, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__bindAssembly*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__bindAssembly location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__bindAssembly, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__bindAssembly::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:bindAssembly", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__bindAssembly::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__bindAssembly(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__bindAssembly * SOAP_FMAC4 soap_get__ns1__bindAssembly(struct soap *soap, _ns1__bindAssembly *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__bindAssembly(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnSaveTechProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnSaveTechProcessResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__SnSaveTechProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcessResponse::out);
#endif
}

int _ns1__SnSaveTechProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnSaveTechProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnSaveTechProcessResponse(struct soap *soap, const char *tag, int id, const _ns1__SnSaveTechProcessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnSaveTechProcessResponse), type))
		return soap->error;
	if (a->out)
		soap_element_result(soap, "ns1:out");
	if (!a->_ns1__SnSaveTechProcessResponse::out)
	{	if (soap_element_nil(soap, "ns1:out"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:out", -1, &a->_ns1__SnSaveTechProcessResponse::out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnSaveTechProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnSaveTechProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcessResponse * SOAP_FMAC4 soap_in__ns1__SnSaveTechProcessResponse(struct soap *soap, const char *tag, _ns1__SnSaveTechProcessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnSaveTechProcessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnSaveTechProcessResponse, sizeof(_ns1__SnSaveTechProcessResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnSaveTechProcessResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnSaveTechProcessResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:out", &a->_ns1__SnSaveTechProcessResponse::out, "xsd:string"))
				{	soap_flag_out1--;
					continue;
				}
			soap_check_result(soap, "ns1:out");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SnSaveTechProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnSaveTechProcessResponse, SOAP_TYPE__ns1__SnSaveTechProcessResponse, sizeof(_ns1__SnSaveTechProcessResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnSaveTechProcessResponse * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnSaveTechProcessResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnSaveTechProcessResponse *p;
	size_t k = sizeof(_ns1__SnSaveTechProcessResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnSaveTechProcessResponse);
		if (p)
			((_ns1__SnSaveTechProcessResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnSaveTechProcessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnSaveTechProcessResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnSaveTechProcessResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnSaveTechProcessResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnSaveTechProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SnSaveTechProcessResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnSaveTechProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnSaveTechProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcessResponse * SOAP_FMAC4 soap_get__ns1__SnSaveTechProcessResponse(struct soap *soap, _ns1__SnSaveTechProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnSaveTechProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SnSaveTechProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SnSaveTechProcess::in0 = NULL;
	this->_ns1__SnSaveTechProcess::in1 = NULL;
	this->_ns1__SnSaveTechProcess::in2 = NULL;
	this->_ns1__SnSaveTechProcess::in3 = NULL;
	this->_ns1__SnSaveTechProcess::in4 = NULL;
	this->_ns1__SnSaveTechProcess::in5 = NULL;
	this->_ns1__SnSaveTechProcess::in6 = NULL;
	this->_ns1__SnSaveTechProcess::in7 = NULL;
	/* transient soap skipped */
}

void _ns1__SnSaveTechProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in0);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in1);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in2);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in3);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in4);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in5);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in6);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SnSaveTechProcess::in7);
#endif
}

int _ns1__SnSaveTechProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SnSaveTechProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SnSaveTechProcess(struct soap *soap, const char *tag, int id, const _ns1__SnSaveTechProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SnSaveTechProcess), type))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in0)
	{	if (soap_element_nil(soap, "ns1:in0"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in0", -1, &a->_ns1__SnSaveTechProcess::in0, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in1)
	{	if (soap_element_nil(soap, "ns1:in1"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in1", -1, &a->_ns1__SnSaveTechProcess::in1, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in2)
	{	if (soap_element_nil(soap, "ns1:in2"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in2", -1, &a->_ns1__SnSaveTechProcess::in2, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in3)
	{	if (soap_element_nil(soap, "ns1:in3"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in3", -1, &a->_ns1__SnSaveTechProcess::in3, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in4)
	{	if (soap_element_nil(soap, "ns1:in4"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in4", -1, &a->_ns1__SnSaveTechProcess::in4, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in5)
	{	if (soap_element_nil(soap, "ns1:in5"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in5", -1, &a->_ns1__SnSaveTechProcess::in5, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in6)
	{	if (soap_element_nil(soap, "ns1:in6"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in6", -1, &a->_ns1__SnSaveTechProcess::in6, ""))
		return soap->error;
	if (!a->_ns1__SnSaveTechProcess::in7)
	{	if (soap_element_nil(soap, "ns1:in7"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostd__string(soap, "ns1:in7", -1, &a->_ns1__SnSaveTechProcess::in7, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SnSaveTechProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SnSaveTechProcess(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess * SOAP_FMAC4 soap_in__ns1__SnSaveTechProcess(struct soap *soap, const char *tag, _ns1__SnSaveTechProcess *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SnSaveTechProcess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SnSaveTechProcess, sizeof(_ns1__SnSaveTechProcess), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SnSaveTechProcess)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SnSaveTechProcess *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_in01 = 1;
	size_t soap_flag_in11 = 1;
	size_t soap_flag_in21 = 1;
	size_t soap_flag_in31 = 1;
	size_t soap_flag_in41 = 1;
	size_t soap_flag_in51 = 1;
	size_t soap_flag_in61 = 1;
	size_t soap_flag_in71 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in0", &a->_ns1__SnSaveTechProcess::in0, "xsd:string"))
				{	soap_flag_in01--;
					continue;
				}
			if (soap_flag_in11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in1", &a->_ns1__SnSaveTechProcess::in1, "xsd:string"))
				{	soap_flag_in11--;
					continue;
				}
			if (soap_flag_in21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in2", &a->_ns1__SnSaveTechProcess::in2, "xsd:string"))
				{	soap_flag_in21--;
					continue;
				}
			if (soap_flag_in31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in3", &a->_ns1__SnSaveTechProcess::in3, "xsd:string"))
				{	soap_flag_in31--;
					continue;
				}
			if (soap_flag_in41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in4", &a->_ns1__SnSaveTechProcess::in4, "xsd:string"))
				{	soap_flag_in41--;
					continue;
				}
			if (soap_flag_in51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in5", &a->_ns1__SnSaveTechProcess::in5, "xsd:string"))
				{	soap_flag_in51--;
					continue;
				}
			if (soap_flag_in61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in6", &a->_ns1__SnSaveTechProcess::in6, "xsd:string"))
				{	soap_flag_in61--;
					continue;
				}
			if (soap_flag_in71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:in7", &a->_ns1__SnSaveTechProcess::in7, "xsd:string"))
				{	soap_flag_in71--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in01 > 0 || soap_flag_in11 > 0 || soap_flag_in21 > 0 || soap_flag_in31 > 0 || soap_flag_in41 > 0 || soap_flag_in51 > 0 || soap_flag_in61 > 0 || soap_flag_in71 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SnSaveTechProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SnSaveTechProcess, SOAP_TYPE__ns1__SnSaveTechProcess, sizeof(_ns1__SnSaveTechProcess), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SnSaveTechProcess * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SnSaveTechProcess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SnSaveTechProcess *p;
	size_t k = sizeof(_ns1__SnSaveTechProcess);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SnSaveTechProcess);
		if (p)
			((_ns1__SnSaveTechProcess*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SnSaveTechProcess, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SnSaveTechProcess*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SnSaveTechProcess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SnSaveTechProcess, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SnSaveTechProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SnSaveTechProcess", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SnSaveTechProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SnSaveTechProcess(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess * SOAP_FMAC4 soap_get__ns1__SnSaveTechProcess(struct soap *soap, _ns1__SnSaveTechProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SnSaveTechProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckTimeGap(struct soap *soap, struct __ns1__CheckTimeGap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckTimeGap = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckTimeGap(struct soap *soap, const struct __ns1__CheckTimeGap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CheckTimeGap(soap, &a->ns1__CheckTimeGap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckTimeGap(struct soap *soap, const char *tag, int id, const struct __ns1__CheckTimeGap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CheckTimeGap(soap, "ns1:CheckTimeGap", -1, &a->ns1__CheckTimeGap, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckTimeGap * SOAP_FMAC4 soap_in___ns1__CheckTimeGap(struct soap *soap, const char *tag, struct __ns1__CheckTimeGap *a, const char *type)
{
	size_t soap_flag_ns1__CheckTimeGap = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CheckTimeGap *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckTimeGap, sizeof(struct __ns1__CheckTimeGap), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckTimeGap(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckTimeGap && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckTimeGap(soap, "ns1:CheckTimeGap", &a->ns1__CheckTimeGap, ""))
				{	soap_flag_ns1__CheckTimeGap--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CheckTimeGap * SOAP_FMAC2 soap_instantiate___ns1__CheckTimeGap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckTimeGap(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CheckTimeGap *p;
	size_t k = sizeof(struct __ns1__CheckTimeGap);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CheckTimeGap);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CheckTimeGap, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CheckTimeGap location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CheckTimeGap, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckTimeGap(struct soap *soap, const struct __ns1__CheckTimeGap *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CheckTimeGap(soap, tag?tag:"-ns1:CheckTimeGap", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckTimeGap * SOAP_FMAC4 soap_get___ns1__CheckTimeGap(struct soap *soap, struct __ns1__CheckTimeGap *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckTimeGap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Ispasspostburnin(struct soap *soap, struct __ns1__Ispasspostburnin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Ispasspostburnin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Ispasspostburnin(struct soap *soap, const struct __ns1__Ispasspostburnin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Ispasspostburnin(soap, &a->ns1__Ispasspostburnin);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Ispasspostburnin(struct soap *soap, const char *tag, int id, const struct __ns1__Ispasspostburnin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Ispasspostburnin(soap, "ns1:Ispasspostburnin", -1, &a->ns1__Ispasspostburnin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Ispasspostburnin * SOAP_FMAC4 soap_in___ns1__Ispasspostburnin(struct soap *soap, const char *tag, struct __ns1__Ispasspostburnin *a, const char *type)
{
	size_t soap_flag_ns1__Ispasspostburnin = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Ispasspostburnin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Ispasspostburnin, sizeof(struct __ns1__Ispasspostburnin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Ispasspostburnin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Ispasspostburnin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Ispasspostburnin(soap, "ns1:Ispasspostburnin", &a->ns1__Ispasspostburnin, ""))
				{	soap_flag_ns1__Ispasspostburnin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Ispasspostburnin * SOAP_FMAC2 soap_instantiate___ns1__Ispasspostburnin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Ispasspostburnin(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Ispasspostburnin *p;
	size_t k = sizeof(struct __ns1__Ispasspostburnin);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Ispasspostburnin);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Ispasspostburnin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Ispasspostburnin location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Ispasspostburnin, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Ispasspostburnin(struct soap *soap, const struct __ns1__Ispasspostburnin *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Ispasspostburnin(soap, tag?tag:"-ns1:Ispasspostburnin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Ispasspostburnin * SOAP_FMAC4 soap_get___ns1__Ispasspostburnin(struct soap *soap, struct __ns1__Ispasspostburnin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Ispasspostburnin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkingSNNextRoute(struct soap *soap, struct __ns1__checkingSNNextRoute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkingSNNextRoute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkingSNNextRoute(struct soap *soap, const struct __ns1__checkingSNNextRoute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkingSNNextRoute(soap, &a->ns1__checkingSNNextRoute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkingSNNextRoute(struct soap *soap, const char *tag, int id, const struct __ns1__checkingSNNextRoute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkingSNNextRoute(soap, "ns1:checkingSNNextRoute", -1, &a->ns1__checkingSNNextRoute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkingSNNextRoute * SOAP_FMAC4 soap_in___ns1__checkingSNNextRoute(struct soap *soap, const char *tag, struct __ns1__checkingSNNextRoute *a, const char *type)
{
	size_t soap_flag_ns1__checkingSNNextRoute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkingSNNextRoute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkingSNNextRoute, sizeof(struct __ns1__checkingSNNextRoute), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkingSNNextRoute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkingSNNextRoute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__checkingSNNextRoute(soap, "ns1:checkingSNNextRoute", &a->ns1__checkingSNNextRoute, ""))
				{	soap_flag_ns1__checkingSNNextRoute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkingSNNextRoute * SOAP_FMAC2 soap_instantiate___ns1__checkingSNNextRoute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkingSNNextRoute(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkingSNNextRoute *p;
	size_t k = sizeof(struct __ns1__checkingSNNextRoute);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkingSNNextRoute);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkingSNNextRoute, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkingSNNextRoute location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkingSNNextRoute, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkingSNNextRoute(struct soap *soap, const struct __ns1__checkingSNNextRoute *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkingSNNextRoute(soap, tag?tag:"-ns1:checkingSNNextRoute", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkingSNNextRoute * SOAP_FMAC4 soap_get___ns1__checkingSNNextRoute(struct soap *soap, struct __ns1__checkingSNNextRoute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkingSNNextRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__blakeTestExchangeData(struct soap *soap, struct __ns1__blakeTestExchangeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__blakeTestExchangeData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__blakeTestExchangeData(struct soap *soap, const struct __ns1__blakeTestExchangeData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__blakeTestExchangeData(soap, &a->ns1__blakeTestExchangeData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__blakeTestExchangeData(struct soap *soap, const char *tag, int id, const struct __ns1__blakeTestExchangeData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__blakeTestExchangeData(soap, "ns1:blakeTestExchangeData", -1, &a->ns1__blakeTestExchangeData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__blakeTestExchangeData * SOAP_FMAC4 soap_in___ns1__blakeTestExchangeData(struct soap *soap, const char *tag, struct __ns1__blakeTestExchangeData *a, const char *type)
{
	size_t soap_flag_ns1__blakeTestExchangeData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__blakeTestExchangeData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__blakeTestExchangeData, sizeof(struct __ns1__blakeTestExchangeData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__blakeTestExchangeData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__blakeTestExchangeData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__blakeTestExchangeData(soap, "ns1:blakeTestExchangeData", &a->ns1__blakeTestExchangeData, ""))
				{	soap_flag_ns1__blakeTestExchangeData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__blakeTestExchangeData * SOAP_FMAC2 soap_instantiate___ns1__blakeTestExchangeData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__blakeTestExchangeData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__blakeTestExchangeData *p;
	size_t k = sizeof(struct __ns1__blakeTestExchangeData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__blakeTestExchangeData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__blakeTestExchangeData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__blakeTestExchangeData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__blakeTestExchangeData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__blakeTestExchangeData(struct soap *soap, const struct __ns1__blakeTestExchangeData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__blakeTestExchangeData(soap, tag?tag:"-ns1:blakeTestExchangeData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__blakeTestExchangeData * SOAP_FMAC4 soap_get___ns1__blakeTestExchangeData(struct soap *soap, struct __ns1__blakeTestExchangeData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__blakeTestExchangeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__goNewRouteseq(struct soap *soap, struct __ns1__goNewRouteseq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__goNewRouteseq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__goNewRouteseq(struct soap *soap, const struct __ns1__goNewRouteseq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__goNewRouteseq(soap, &a->ns1__goNewRouteseq);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__goNewRouteseq(struct soap *soap, const char *tag, int id, const struct __ns1__goNewRouteseq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__goNewRouteseq(soap, "ns1:goNewRouteseq", -1, &a->ns1__goNewRouteseq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__goNewRouteseq * SOAP_FMAC4 soap_in___ns1__goNewRouteseq(struct soap *soap, const char *tag, struct __ns1__goNewRouteseq *a, const char *type)
{
	size_t soap_flag_ns1__goNewRouteseq = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__goNewRouteseq *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__goNewRouteseq, sizeof(struct __ns1__goNewRouteseq), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__goNewRouteseq(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__goNewRouteseq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__goNewRouteseq(soap, "ns1:goNewRouteseq", &a->ns1__goNewRouteseq, ""))
				{	soap_flag_ns1__goNewRouteseq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__goNewRouteseq * SOAP_FMAC2 soap_instantiate___ns1__goNewRouteseq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__goNewRouteseq(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__goNewRouteseq *p;
	size_t k = sizeof(struct __ns1__goNewRouteseq);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__goNewRouteseq);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__goNewRouteseq, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__goNewRouteseq location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__goNewRouteseq, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__goNewRouteseq(struct soap *soap, const struct __ns1__goNewRouteseq *a, const char *tag, const char *type)
{
	if (soap_out___ns1__goNewRouteseq(soap, tag?tag:"-ns1:goNewRouteseq", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__goNewRouteseq * SOAP_FMAC4 soap_get___ns1__goNewRouteseq(struct soap *soap, struct __ns1__goNewRouteseq *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__goNewRouteseq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fetchSnCurrentLocation(struct soap *soap, struct __ns1__fetchSnCurrentLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fetchSnCurrentLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fetchSnCurrentLocation(struct soap *soap, const struct __ns1__fetchSnCurrentLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__fetchSnCurrentLocation(soap, &a->ns1__fetchSnCurrentLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, int id, const struct __ns1__fetchSnCurrentLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__fetchSnCurrentLocation(soap, "ns1:fetchSnCurrentLocation", -1, &a->ns1__fetchSnCurrentLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchSnCurrentLocation * SOAP_FMAC4 soap_in___ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, struct __ns1__fetchSnCurrentLocation *a, const char *type)
{
	size_t soap_flag_ns1__fetchSnCurrentLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__fetchSnCurrentLocation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fetchSnCurrentLocation, sizeof(struct __ns1__fetchSnCurrentLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fetchSnCurrentLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fetchSnCurrentLocation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__fetchSnCurrentLocation(soap, "ns1:fetchSnCurrentLocation", &a->ns1__fetchSnCurrentLocation, ""))
				{	soap_flag_ns1__fetchSnCurrentLocation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__fetchSnCurrentLocation * SOAP_FMAC2 soap_instantiate___ns1__fetchSnCurrentLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fetchSnCurrentLocation(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__fetchSnCurrentLocation *p;
	size_t k = sizeof(struct __ns1__fetchSnCurrentLocation);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__fetchSnCurrentLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__fetchSnCurrentLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__fetchSnCurrentLocation location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__fetchSnCurrentLocation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fetchSnCurrentLocation(struct soap *soap, const struct __ns1__fetchSnCurrentLocation *a, const char *tag, const char *type)
{
	if (soap_out___ns1__fetchSnCurrentLocation(soap, tag?tag:"-ns1:fetchSnCurrentLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchSnCurrentLocation * SOAP_FMAC4 soap_get___ns1__fetchSnCurrentLocation(struct soap *soap, struct __ns1__fetchSnCurrentLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fetchSnCurrentLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMaintanceParm(struct soap *soap, struct __ns1__getMaintanceParm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMaintanceParm = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMaintanceParm(struct soap *soap, const struct __ns1__getMaintanceParm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getMaintanceParm(soap, &a->ns1__getMaintanceParm);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMaintanceParm(struct soap *soap, const char *tag, int id, const struct __ns1__getMaintanceParm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getMaintanceParm(soap, "ns1:getMaintanceParm", -1, &a->ns1__getMaintanceParm, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMaintanceParm * SOAP_FMAC4 soap_in___ns1__getMaintanceParm(struct soap *soap, const char *tag, struct __ns1__getMaintanceParm *a, const char *type)
{
	size_t soap_flag_ns1__getMaintanceParm = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getMaintanceParm *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMaintanceParm, sizeof(struct __ns1__getMaintanceParm), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMaintanceParm(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMaintanceParm && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getMaintanceParm(soap, "ns1:getMaintanceParm", &a->ns1__getMaintanceParm, ""))
				{	soap_flag_ns1__getMaintanceParm--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getMaintanceParm * SOAP_FMAC2 soap_instantiate___ns1__getMaintanceParm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMaintanceParm(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getMaintanceParm *p;
	size_t k = sizeof(struct __ns1__getMaintanceParm);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getMaintanceParm);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getMaintanceParm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getMaintanceParm location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getMaintanceParm, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMaintanceParm(struct soap *soap, const struct __ns1__getMaintanceParm *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getMaintanceParm(soap, tag?tag:"-ns1:getMaintanceParm", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMaintanceParm * SOAP_FMAC4 soap_get___ns1__getMaintanceParm(struct soap *soap, struct __ns1__getMaintanceParm *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMaintanceParm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkMac(struct soap *soap, struct __ns1__checkMac *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkMac = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkMac(struct soap *soap, const struct __ns1__checkMac *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkMac(soap, &a->ns1__checkMac);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkMac(struct soap *soap, const char *tag, int id, const struct __ns1__checkMac *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkMac(soap, "ns1:checkMac", -1, &a->ns1__checkMac, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkMac * SOAP_FMAC4 soap_in___ns1__checkMac(struct soap *soap, const char *tag, struct __ns1__checkMac *a, const char *type)
{
	size_t soap_flag_ns1__checkMac = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkMac *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkMac, sizeof(struct __ns1__checkMac), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkMac(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkMac && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__checkMac(soap, "ns1:checkMac", &a->ns1__checkMac, ""))
				{	soap_flag_ns1__checkMac--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkMac * SOAP_FMAC2 soap_instantiate___ns1__checkMac(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkMac(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkMac *p;
	size_t k = sizeof(struct __ns1__checkMac);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkMac);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkMac, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkMac location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkMac, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkMac(struct soap *soap, const struct __ns1__checkMac *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkMac(soap, tag?tag:"-ns1:checkMac", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkMac * SOAP_FMAC4 soap_get___ns1__checkMac(struct soap *soap, struct __ns1__checkMac *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkMac(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsertTimeControl(struct soap *soap, struct __ns1__InsertTimeControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsertTimeControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsertTimeControl(struct soap *soap, const struct __ns1__InsertTimeControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsertTimeControl(soap, &a->ns1__InsertTimeControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsertTimeControl(struct soap *soap, const char *tag, int id, const struct __ns1__InsertTimeControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsertTimeControl(soap, "ns1:InsertTimeControl", -1, &a->ns1__InsertTimeControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertTimeControl * SOAP_FMAC4 soap_in___ns1__InsertTimeControl(struct soap *soap, const char *tag, struct __ns1__InsertTimeControl *a, const char *type)
{
	size_t soap_flag_ns1__InsertTimeControl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsertTimeControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsertTimeControl, sizeof(struct __ns1__InsertTimeControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsertTimeControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsertTimeControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InsertTimeControl(soap, "ns1:InsertTimeControl", &a->ns1__InsertTimeControl, ""))
				{	soap_flag_ns1__InsertTimeControl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsertTimeControl * SOAP_FMAC2 soap_instantiate___ns1__InsertTimeControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsertTimeControl(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsertTimeControl *p;
	size_t k = sizeof(struct __ns1__InsertTimeControl);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsertTimeControl);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsertTimeControl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsertTimeControl location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsertTimeControl, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsertTimeControl(struct soap *soap, const struct __ns1__InsertTimeControl *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsertTimeControl(soap, tag?tag:"-ns1:InsertTimeControl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertTimeControl * SOAP_FMAC4 soap_get___ns1__InsertTimeControl(struct soap *soap, struct __ns1__InsertTimeControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsertTimeControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__blakeTestExchangeData1(struct soap *soap, struct __ns1__blakeTestExchangeData1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__blakeTestExchangeData1 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__blakeTestExchangeData1(struct soap *soap, const struct __ns1__blakeTestExchangeData1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__blakeTestExchangeData1(soap, &a->ns1__blakeTestExchangeData1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, int id, const struct __ns1__blakeTestExchangeData1 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__blakeTestExchangeData1(soap, "ns1:blakeTestExchangeData1", -1, &a->ns1__blakeTestExchangeData1, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__blakeTestExchangeData1 * SOAP_FMAC4 soap_in___ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, struct __ns1__blakeTestExchangeData1 *a, const char *type)
{
	size_t soap_flag_ns1__blakeTestExchangeData1 = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__blakeTestExchangeData1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__blakeTestExchangeData1, sizeof(struct __ns1__blakeTestExchangeData1), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__blakeTestExchangeData1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__blakeTestExchangeData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__blakeTestExchangeData1(soap, "ns1:blakeTestExchangeData1", &a->ns1__blakeTestExchangeData1, ""))
				{	soap_flag_ns1__blakeTestExchangeData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__blakeTestExchangeData1 * SOAP_FMAC2 soap_instantiate___ns1__blakeTestExchangeData1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__blakeTestExchangeData1(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__blakeTestExchangeData1 *p;
	size_t k = sizeof(struct __ns1__blakeTestExchangeData1);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__blakeTestExchangeData1);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__blakeTestExchangeData1, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__blakeTestExchangeData1 location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__blakeTestExchangeData1, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__blakeTestExchangeData1(struct soap *soap, const struct __ns1__blakeTestExchangeData1 *a, const char *tag, const char *type)
{
	if (soap_out___ns1__blakeTestExchangeData1(soap, tag?tag:"-ns1:blakeTestExchangeData1", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__blakeTestExchangeData1 * SOAP_FMAC4 soap_get___ns1__blakeTestExchangeData1(struct soap *soap, struct __ns1__blakeTestExchangeData1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__blakeTestExchangeData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InsertPRateData(struct soap *soap, struct __ns1__InsertPRateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InsertPRateData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InsertPRateData(struct soap *soap, const struct __ns1__InsertPRateData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InsertPRateData(soap, &a->ns1__InsertPRateData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InsertPRateData(struct soap *soap, const char *tag, int id, const struct __ns1__InsertPRateData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InsertPRateData(soap, "ns1:InsertPRateData", -1, &a->ns1__InsertPRateData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertPRateData * SOAP_FMAC4 soap_in___ns1__InsertPRateData(struct soap *soap, const char *tag, struct __ns1__InsertPRateData *a, const char *type)
{
	size_t soap_flag_ns1__InsertPRateData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__InsertPRateData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InsertPRateData, sizeof(struct __ns1__InsertPRateData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InsertPRateData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InsertPRateData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InsertPRateData(soap, "ns1:InsertPRateData", &a->ns1__InsertPRateData, ""))
				{	soap_flag_ns1__InsertPRateData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__InsertPRateData * SOAP_FMAC2 soap_instantiate___ns1__InsertPRateData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InsertPRateData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__InsertPRateData *p;
	size_t k = sizeof(struct __ns1__InsertPRateData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__InsertPRateData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__InsertPRateData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__InsertPRateData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__InsertPRateData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InsertPRateData(struct soap *soap, const struct __ns1__InsertPRateData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__InsertPRateData(soap, tag?tag:"-ns1:InsertPRateData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InsertPRateData * SOAP_FMAC4 soap_get___ns1__InsertPRateData(struct soap *soap, struct __ns1__InsertPRateData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InsertPRateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAssemblyData(struct soap *soap, struct __ns1__getAssemblyData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAssemblyData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAssemblyData(struct soap *soap, const struct __ns1__getAssemblyData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getAssemblyData(soap, &a->ns1__getAssemblyData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAssemblyData(struct soap *soap, const char *tag, int id, const struct __ns1__getAssemblyData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getAssemblyData(soap, "ns1:getAssemblyData", -1, &a->ns1__getAssemblyData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAssemblyData * SOAP_FMAC4 soap_in___ns1__getAssemblyData(struct soap *soap, const char *tag, struct __ns1__getAssemblyData *a, const char *type)
{
	size_t soap_flag_ns1__getAssemblyData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getAssemblyData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAssemblyData, sizeof(struct __ns1__getAssemblyData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAssemblyData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAssemblyData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAssemblyData(soap, "ns1:getAssemblyData", &a->ns1__getAssemblyData, ""))
				{	soap_flag_ns1__getAssemblyData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getAssemblyData * SOAP_FMAC2 soap_instantiate___ns1__getAssemblyData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAssemblyData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getAssemblyData *p;
	size_t k = sizeof(struct __ns1__getAssemblyData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getAssemblyData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getAssemblyData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getAssemblyData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getAssemblyData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAssemblyData(struct soap *soap, const struct __ns1__getAssemblyData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getAssemblyData(soap, tag?tag:"-ns1:getAssemblyData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAssemblyData * SOAP_FMAC4 soap_get___ns1__getAssemblyData(struct soap *soap, struct __ns1__getAssemblyData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAssemblyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__staffCheck(struct soap *soap, struct __ns1__staffCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__staffCheck = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__staffCheck(struct soap *soap, const struct __ns1__staffCheck *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__staffCheck(soap, &a->ns1__staffCheck);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__staffCheck(struct soap *soap, const char *tag, int id, const struct __ns1__staffCheck *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__staffCheck(soap, "ns1:staffCheck", -1, &a->ns1__staffCheck, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__staffCheck * SOAP_FMAC4 soap_in___ns1__staffCheck(struct soap *soap, const char *tag, struct __ns1__staffCheck *a, const char *type)
{
	size_t soap_flag_ns1__staffCheck = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__staffCheck *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__staffCheck, sizeof(struct __ns1__staffCheck), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__staffCheck(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__staffCheck && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__staffCheck(soap, "ns1:staffCheck", &a->ns1__staffCheck, ""))
				{	soap_flag_ns1__staffCheck--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__staffCheck * SOAP_FMAC2 soap_instantiate___ns1__staffCheck(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__staffCheck(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__staffCheck *p;
	size_t k = sizeof(struct __ns1__staffCheck);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__staffCheck);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__staffCheck, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__staffCheck location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__staffCheck, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__staffCheck(struct soap *soap, const struct __ns1__staffCheck *a, const char *tag, const char *type)
{
	if (soap_out___ns1__staffCheck(soap, tag?tag:"-ns1:staffCheck", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__staffCheck * SOAP_FMAC4 soap_get___ns1__staffCheck(struct soap *soap, struct __ns1__staffCheck *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__staffCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, struct __ns1__SnSaveTechProcess_USCOREA *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnSaveTechProcess_USCOREA = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const struct __ns1__SnSaveTechProcess_USCOREA *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, &a->ns1__SnSaveTechProcess_USCOREA);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, int id, const struct __ns1__SnSaveTechProcess_USCOREA *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, "ns1:SnSaveTechProcess_A", -1, &a->ns1__SnSaveTechProcess_USCOREA, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC4 soap_in___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, struct __ns1__SnSaveTechProcess_USCOREA *a, const char *type)
{
	size_t soap_flag_ns1__SnSaveTechProcess_USCOREA = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnSaveTechProcess_USCOREA *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA, sizeof(struct __ns1__SnSaveTechProcess_USCOREA), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnSaveTechProcess_USCOREA(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnSaveTechProcess_USCOREA && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, "ns1:SnSaveTechProcess_A", &a->ns1__SnSaveTechProcess_USCOREA, ""))
				{	soap_flag_ns1__SnSaveTechProcess_USCOREA--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC2 soap_instantiate___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnSaveTechProcess_USCOREA(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnSaveTechProcess_USCOREA *p;
	size_t k = sizeof(struct __ns1__SnSaveTechProcess_USCOREA);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnSaveTechProcess_USCOREA);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnSaveTechProcess_USCOREA, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnSaveTechProcess_USCOREA location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const struct __ns1__SnSaveTechProcess_USCOREA *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnSaveTechProcess_USCOREA(soap, tag?tag:"-ns1:SnSaveTechProcess_A", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC4 soap_get___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, struct __ns1__SnSaveTechProcess_USCOREA *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnSaveTechProcess_USCOREA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSNPangusOrderNo(struct soap *soap, struct __ns1__checkSNPangusOrderNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSNPangusOrderNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSNPangusOrderNo(struct soap *soap, const struct __ns1__checkSNPangusOrderNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSNPangusOrderNo(soap, &a->ns1__checkSNPangusOrderNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, int id, const struct __ns1__checkSNPangusOrderNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSNPangusOrderNo(soap, "ns1:checkSNPangusOrderNo", -1, &a->ns1__checkSNPangusOrderNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSNPangusOrderNo * SOAP_FMAC4 soap_in___ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, struct __ns1__checkSNPangusOrderNo *a, const char *type)
{
	size_t soap_flag_ns1__checkSNPangusOrderNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSNPangusOrderNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSNPangusOrderNo, sizeof(struct __ns1__checkSNPangusOrderNo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSNPangusOrderNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSNPangusOrderNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__checkSNPangusOrderNo(soap, "ns1:checkSNPangusOrderNo", &a->ns1__checkSNPangusOrderNo, ""))
				{	soap_flag_ns1__checkSNPangusOrderNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSNPangusOrderNo * SOAP_FMAC2 soap_instantiate___ns1__checkSNPangusOrderNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSNPangusOrderNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSNPangusOrderNo *p;
	size_t k = sizeof(struct __ns1__checkSNPangusOrderNo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSNPangusOrderNo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSNPangusOrderNo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSNPangusOrderNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSNPangusOrderNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSNPangusOrderNo(struct soap *soap, const struct __ns1__checkSNPangusOrderNo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSNPangusOrderNo(soap, tag?tag:"-ns1:checkSNPangusOrderNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSNPangusOrderNo * SOAP_FMAC4 soap_get___ns1__checkSNPangusOrderNo(struct soap *soap, struct __ns1__checkSNPangusOrderNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSNPangusOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkSNOrderNo(struct soap *soap, struct __ns1__checkSNOrderNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkSNOrderNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkSNOrderNo(struct soap *soap, const struct __ns1__checkSNOrderNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__checkSNOrderNo(soap, &a->ns1__checkSNOrderNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkSNOrderNo(struct soap *soap, const char *tag, int id, const struct __ns1__checkSNOrderNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__checkSNOrderNo(soap, "ns1:checkSNOrderNo", -1, &a->ns1__checkSNOrderNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSNOrderNo * SOAP_FMAC4 soap_in___ns1__checkSNOrderNo(struct soap *soap, const char *tag, struct __ns1__checkSNOrderNo *a, const char *type)
{
	size_t soap_flag_ns1__checkSNOrderNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__checkSNOrderNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkSNOrderNo, sizeof(struct __ns1__checkSNOrderNo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkSNOrderNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkSNOrderNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__checkSNOrderNo(soap, "ns1:checkSNOrderNo", &a->ns1__checkSNOrderNo, ""))
				{	soap_flag_ns1__checkSNOrderNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__checkSNOrderNo * SOAP_FMAC2 soap_instantiate___ns1__checkSNOrderNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkSNOrderNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__checkSNOrderNo *p;
	size_t k = sizeof(struct __ns1__checkSNOrderNo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__checkSNOrderNo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__checkSNOrderNo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__checkSNOrderNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__checkSNOrderNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkSNOrderNo(struct soap *soap, const struct __ns1__checkSNOrderNo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__checkSNOrderNo(soap, tag?tag:"-ns1:checkSNOrderNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkSNOrderNo * SOAP_FMAC4 soap_get___ns1__checkSNOrderNo(struct soap *soap, struct __ns1__checkSNOrderNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkSNOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadNgPanelNo(struct soap *soap, struct __ns1__loadNgPanelNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadNgPanelNo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadNgPanelNo(struct soap *soap, const struct __ns1__loadNgPanelNo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__loadNgPanelNo(soap, &a->ns1__loadNgPanelNo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadNgPanelNo(struct soap *soap, const char *tag, int id, const struct __ns1__loadNgPanelNo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__loadNgPanelNo(soap, "ns1:loadNgPanelNo", -1, &a->ns1__loadNgPanelNo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadNgPanelNo * SOAP_FMAC4 soap_in___ns1__loadNgPanelNo(struct soap *soap, const char *tag, struct __ns1__loadNgPanelNo *a, const char *type)
{
	size_t soap_flag_ns1__loadNgPanelNo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadNgPanelNo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadNgPanelNo, sizeof(struct __ns1__loadNgPanelNo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadNgPanelNo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadNgPanelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__loadNgPanelNo(soap, "ns1:loadNgPanelNo", &a->ns1__loadNgPanelNo, ""))
				{	soap_flag_ns1__loadNgPanelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__loadNgPanelNo * SOAP_FMAC2 soap_instantiate___ns1__loadNgPanelNo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadNgPanelNo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__loadNgPanelNo *p;
	size_t k = sizeof(struct __ns1__loadNgPanelNo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__loadNgPanelNo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__loadNgPanelNo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__loadNgPanelNo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__loadNgPanelNo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadNgPanelNo(struct soap *soap, const struct __ns1__loadNgPanelNo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__loadNgPanelNo(soap, tag?tag:"-ns1:loadNgPanelNo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadNgPanelNo * SOAP_FMAC4 soap_get___ns1__loadNgPanelNo(struct soap *soap, struct __ns1__loadNgPanelNo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadNgPanelNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__loadTimeControlData(struct soap *soap, struct __ns1__loadTimeControlData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__loadTimeControlData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__loadTimeControlData(struct soap *soap, const struct __ns1__loadTimeControlData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__loadTimeControlData(soap, &a->ns1__loadTimeControlData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__loadTimeControlData(struct soap *soap, const char *tag, int id, const struct __ns1__loadTimeControlData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__loadTimeControlData(soap, "ns1:loadTimeControlData", -1, &a->ns1__loadTimeControlData, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadTimeControlData * SOAP_FMAC4 soap_in___ns1__loadTimeControlData(struct soap *soap, const char *tag, struct __ns1__loadTimeControlData *a, const char *type)
{
	size_t soap_flag_ns1__loadTimeControlData = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__loadTimeControlData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__loadTimeControlData, sizeof(struct __ns1__loadTimeControlData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__loadTimeControlData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__loadTimeControlData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__loadTimeControlData(soap, "ns1:loadTimeControlData", &a->ns1__loadTimeControlData, ""))
				{	soap_flag_ns1__loadTimeControlData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__loadTimeControlData * SOAP_FMAC2 soap_instantiate___ns1__loadTimeControlData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__loadTimeControlData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__loadTimeControlData *p;
	size_t k = sizeof(struct __ns1__loadTimeControlData);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__loadTimeControlData);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__loadTimeControlData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__loadTimeControlData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__loadTimeControlData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__loadTimeControlData(struct soap *soap, const struct __ns1__loadTimeControlData *a, const char *tag, const char *type)
{
	if (soap_out___ns1__loadTimeControlData(soap, tag?tag:"-ns1:loadTimeControlData", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__loadTimeControlData * SOAP_FMAC4 soap_get___ns1__loadTimeControlData(struct soap *soap, struct __ns1__loadTimeControlData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__loadTimeControlData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bindAssembly(struct soap *soap, struct __ns1__bindAssembly *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__bindAssembly = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bindAssembly(struct soap *soap, const struct __ns1__bindAssembly *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__bindAssembly(soap, &a->ns1__bindAssembly);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bindAssembly(struct soap *soap, const char *tag, int id, const struct __ns1__bindAssembly *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__bindAssembly(soap, "ns1:bindAssembly", -1, &a->ns1__bindAssembly, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bindAssembly * SOAP_FMAC4 soap_in___ns1__bindAssembly(struct soap *soap, const char *tag, struct __ns1__bindAssembly *a, const char *type)
{
	size_t soap_flag_ns1__bindAssembly = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__bindAssembly *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bindAssembly, sizeof(struct __ns1__bindAssembly), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bindAssembly(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__bindAssembly && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__bindAssembly(soap, "ns1:bindAssembly", &a->ns1__bindAssembly, ""))
				{	soap_flag_ns1__bindAssembly--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__bindAssembly * SOAP_FMAC2 soap_instantiate___ns1__bindAssembly(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__bindAssembly(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__bindAssembly *p;
	size_t k = sizeof(struct __ns1__bindAssembly);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__bindAssembly);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__bindAssembly, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__bindAssembly location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__bindAssembly, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bindAssembly(struct soap *soap, const struct __ns1__bindAssembly *a, const char *tag, const char *type)
{
	if (soap_out___ns1__bindAssembly(soap, tag?tag:"-ns1:bindAssembly", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bindAssembly * SOAP_FMAC4 soap_get___ns1__bindAssembly(struct soap *soap, struct __ns1__bindAssembly *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bindAssembly(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SnSaveTechProcess(struct soap *soap, struct __ns1__SnSaveTechProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SnSaveTechProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SnSaveTechProcess(struct soap *soap, const struct __ns1__SnSaveTechProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SnSaveTechProcess(soap, &a->ns1__SnSaveTechProcess);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SnSaveTechProcess(struct soap *soap, const char *tag, int id, const struct __ns1__SnSaveTechProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SnSaveTechProcess(soap, "ns1:SnSaveTechProcess", -1, &a->ns1__SnSaveTechProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnSaveTechProcess * SOAP_FMAC4 soap_in___ns1__SnSaveTechProcess(struct soap *soap, const char *tag, struct __ns1__SnSaveTechProcess *a, const char *type)
{
	size_t soap_flag_ns1__SnSaveTechProcess = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SnSaveTechProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SnSaveTechProcess, sizeof(struct __ns1__SnSaveTechProcess), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SnSaveTechProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SnSaveTechProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SnSaveTechProcess(soap, "ns1:SnSaveTechProcess", &a->ns1__SnSaveTechProcess, ""))
				{	soap_flag_ns1__SnSaveTechProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SnSaveTechProcess * SOAP_FMAC2 soap_instantiate___ns1__SnSaveTechProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SnSaveTechProcess(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SnSaveTechProcess *p;
	size_t k = sizeof(struct __ns1__SnSaveTechProcess);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__SnSaveTechProcess);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__SnSaveTechProcess, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SnSaveTechProcess location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__SnSaveTechProcess, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SnSaveTechProcess(struct soap *soap, const struct __ns1__SnSaveTechProcess *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SnSaveTechProcess(soap, tag?tag:"-ns1:SnSaveTechProcess", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SnSaveTechProcess * SOAP_FMAC4 soap_get___ns1__SnSaveTechProcess(struct soap *soap, struct __ns1__SnSaveTechProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SnSaveTechProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckTimeGap(struct soap *soap, _ns1__CheckTimeGap *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckTimeGap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckTimeGap(struct soap *soap, const char *tag, int id, _ns1__CheckTimeGap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckTimeGap, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CheckTimeGap ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckTimeGap(struct soap *soap, const char *tag, _ns1__CheckTimeGap **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckTimeGap **)soap_malloc(soap, sizeof(_ns1__CheckTimeGap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckTimeGap *)soap_instantiate__ns1__CheckTimeGap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CheckTimeGap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckTimeGap, sizeof(_ns1__CheckTimeGap), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckTimeGap(struct soap *soap, _ns1__CheckTimeGap *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CheckTimeGap(soap, tag?tag:"ns1:CheckTimeGap", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckTimeGap ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckTimeGap(struct soap *soap, _ns1__CheckTimeGap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckTimeGap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Ispasspostburnin(struct soap *soap, _ns1__Ispasspostburnin *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Ispasspostburnin))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Ispasspostburnin(struct soap *soap, const char *tag, int id, _ns1__Ispasspostburnin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Ispasspostburnin, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Ispasspostburnin ** SOAP_FMAC4 soap_in_PointerTo_ns1__Ispasspostburnin(struct soap *soap, const char *tag, _ns1__Ispasspostburnin **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Ispasspostburnin **)soap_malloc(soap, sizeof(_ns1__Ispasspostburnin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Ispasspostburnin *)soap_instantiate__ns1__Ispasspostburnin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Ispasspostburnin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Ispasspostburnin, sizeof(_ns1__Ispasspostburnin), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Ispasspostburnin(struct soap *soap, _ns1__Ispasspostburnin *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Ispasspostburnin(soap, tag?tag:"ns1:Ispasspostburnin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Ispasspostburnin ** SOAP_FMAC4 soap_get_PointerTo_ns1__Ispasspostburnin(struct soap *soap, _ns1__Ispasspostburnin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Ispasspostburnin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkingSNNextRoute(struct soap *soap, _ns1__checkingSNNextRoute *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkingSNNextRoute))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkingSNNextRoute(struct soap *soap, const char *tag, int id, _ns1__checkingSNNextRoute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkingSNNextRoute, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__checkingSNNextRoute ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkingSNNextRoute(struct soap *soap, const char *tag, _ns1__checkingSNNextRoute **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkingSNNextRoute **)soap_malloc(soap, sizeof(_ns1__checkingSNNextRoute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkingSNNextRoute *)soap_instantiate__ns1__checkingSNNextRoute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkingSNNextRoute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkingSNNextRoute, sizeof(_ns1__checkingSNNextRoute), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkingSNNextRoute(struct soap *soap, _ns1__checkingSNNextRoute *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkingSNNextRoute(soap, tag?tag:"ns1:checkingSNNextRoute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkingSNNextRoute ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkingSNNextRoute(struct soap *soap, _ns1__checkingSNNextRoute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkingSNNextRoute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__blakeTestExchangeData(struct soap *soap, _ns1__blakeTestExchangeData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__blakeTestExchangeData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__blakeTestExchangeData(struct soap *soap, const char *tag, int id, _ns1__blakeTestExchangeData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__blakeTestExchangeData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData ** SOAP_FMAC4 soap_in_PointerTo_ns1__blakeTestExchangeData(struct soap *soap, const char *tag, _ns1__blakeTestExchangeData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__blakeTestExchangeData **)soap_malloc(soap, sizeof(_ns1__blakeTestExchangeData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__blakeTestExchangeData *)soap_instantiate__ns1__blakeTestExchangeData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__blakeTestExchangeData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__blakeTestExchangeData, sizeof(_ns1__blakeTestExchangeData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__blakeTestExchangeData(struct soap *soap, _ns1__blakeTestExchangeData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__blakeTestExchangeData(soap, tag?tag:"ns1:blakeTestExchangeData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData ** SOAP_FMAC4 soap_get_PointerTo_ns1__blakeTestExchangeData(struct soap *soap, _ns1__blakeTestExchangeData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__blakeTestExchangeData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__goNewRouteseq(struct soap *soap, _ns1__goNewRouteseq *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__goNewRouteseq))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__goNewRouteseq(struct soap *soap, const char *tag, int id, _ns1__goNewRouteseq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__goNewRouteseq, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__goNewRouteseq ** SOAP_FMAC4 soap_in_PointerTo_ns1__goNewRouteseq(struct soap *soap, const char *tag, _ns1__goNewRouteseq **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__goNewRouteseq **)soap_malloc(soap, sizeof(_ns1__goNewRouteseq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__goNewRouteseq *)soap_instantiate__ns1__goNewRouteseq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__goNewRouteseq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__goNewRouteseq, sizeof(_ns1__goNewRouteseq), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__goNewRouteseq(struct soap *soap, _ns1__goNewRouteseq *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__goNewRouteseq(soap, tag?tag:"ns1:goNewRouteseq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__goNewRouteseq ** SOAP_FMAC4 soap_get_PointerTo_ns1__goNewRouteseq(struct soap *soap, _ns1__goNewRouteseq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__goNewRouteseq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__fetchSnCurrentLocation(struct soap *soap, _ns1__fetchSnCurrentLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__fetchSnCurrentLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, int id, _ns1__fetchSnCurrentLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__fetchSnCurrentLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocation ** SOAP_FMAC4 soap_in_PointerTo_ns1__fetchSnCurrentLocation(struct soap *soap, const char *tag, _ns1__fetchSnCurrentLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__fetchSnCurrentLocation **)soap_malloc(soap, sizeof(_ns1__fetchSnCurrentLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__fetchSnCurrentLocation *)soap_instantiate__ns1__fetchSnCurrentLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__fetchSnCurrentLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__fetchSnCurrentLocation, sizeof(_ns1__fetchSnCurrentLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__fetchSnCurrentLocation(struct soap *soap, _ns1__fetchSnCurrentLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__fetchSnCurrentLocation(soap, tag?tag:"ns1:fetchSnCurrentLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__fetchSnCurrentLocation ** SOAP_FMAC4 soap_get_PointerTo_ns1__fetchSnCurrentLocation(struct soap *soap, _ns1__fetchSnCurrentLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__fetchSnCurrentLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getMaintanceParm(struct soap *soap, _ns1__getMaintanceParm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getMaintanceParm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getMaintanceParm(struct soap *soap, const char *tag, int id, _ns1__getMaintanceParm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getMaintanceParm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getMaintanceParm ** SOAP_FMAC4 soap_in_PointerTo_ns1__getMaintanceParm(struct soap *soap, const char *tag, _ns1__getMaintanceParm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getMaintanceParm **)soap_malloc(soap, sizeof(_ns1__getMaintanceParm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getMaintanceParm *)soap_instantiate__ns1__getMaintanceParm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getMaintanceParm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getMaintanceParm, sizeof(_ns1__getMaintanceParm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getMaintanceParm(struct soap *soap, _ns1__getMaintanceParm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getMaintanceParm(soap, tag?tag:"ns1:getMaintanceParm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getMaintanceParm ** SOAP_FMAC4 soap_get_PointerTo_ns1__getMaintanceParm(struct soap *soap, _ns1__getMaintanceParm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getMaintanceParm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkMac(struct soap *soap, _ns1__checkMac *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkMac))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkMac(struct soap *soap, const char *tag, int id, _ns1__checkMac *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkMac, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__checkMac ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkMac(struct soap *soap, const char *tag, _ns1__checkMac **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkMac **)soap_malloc(soap, sizeof(_ns1__checkMac *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkMac *)soap_instantiate__ns1__checkMac(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkMac **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkMac, sizeof(_ns1__checkMac), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkMac(struct soap *soap, _ns1__checkMac *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkMac(soap, tag?tag:"ns1:checkMac", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkMac ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkMac(struct soap *soap, _ns1__checkMac **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkMac(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsertTimeControl(struct soap *soap, _ns1__InsertTimeControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsertTimeControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsertTimeControl(struct soap *soap, const char *tag, int id, _ns1__InsertTimeControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsertTimeControl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InsertTimeControl ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsertTimeControl(struct soap *soap, const char *tag, _ns1__InsertTimeControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsertTimeControl **)soap_malloc(soap, sizeof(_ns1__InsertTimeControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsertTimeControl *)soap_instantiate__ns1__InsertTimeControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsertTimeControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsertTimeControl, sizeof(_ns1__InsertTimeControl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsertTimeControl(struct soap *soap, _ns1__InsertTimeControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsertTimeControl(soap, tag?tag:"ns1:InsertTimeControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsertTimeControl ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsertTimeControl(struct soap *soap, _ns1__InsertTimeControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsertTimeControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__blakeTestExchangeData1(struct soap *soap, _ns1__blakeTestExchangeData1 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__blakeTestExchangeData1))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, int id, _ns1__blakeTestExchangeData1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__blakeTestExchangeData1, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1 ** SOAP_FMAC4 soap_in_PointerTo_ns1__blakeTestExchangeData1(struct soap *soap, const char *tag, _ns1__blakeTestExchangeData1 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__blakeTestExchangeData1 **)soap_malloc(soap, sizeof(_ns1__blakeTestExchangeData1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__blakeTestExchangeData1 *)soap_instantiate__ns1__blakeTestExchangeData1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__blakeTestExchangeData1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__blakeTestExchangeData1, sizeof(_ns1__blakeTestExchangeData1), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__blakeTestExchangeData1(struct soap *soap, _ns1__blakeTestExchangeData1 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__blakeTestExchangeData1(soap, tag?tag:"ns1:blakeTestExchangeData1", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__blakeTestExchangeData1 ** SOAP_FMAC4 soap_get_PointerTo_ns1__blakeTestExchangeData1(struct soap *soap, _ns1__blakeTestExchangeData1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__blakeTestExchangeData1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InsertPRateData(struct soap *soap, _ns1__InsertPRateData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InsertPRateData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InsertPRateData(struct soap *soap, const char *tag, int id, _ns1__InsertPRateData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InsertPRateData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InsertPRateData ** SOAP_FMAC4 soap_in_PointerTo_ns1__InsertPRateData(struct soap *soap, const char *tag, _ns1__InsertPRateData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InsertPRateData **)soap_malloc(soap, sizeof(_ns1__InsertPRateData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InsertPRateData *)soap_instantiate__ns1__InsertPRateData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InsertPRateData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InsertPRateData, sizeof(_ns1__InsertPRateData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InsertPRateData(struct soap *soap, _ns1__InsertPRateData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InsertPRateData(soap, tag?tag:"ns1:InsertPRateData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InsertPRateData ** SOAP_FMAC4 soap_get_PointerTo_ns1__InsertPRateData(struct soap *soap, _ns1__InsertPRateData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InsertPRateData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAssemblyData(struct soap *soap, _ns1__getAssemblyData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAssemblyData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAssemblyData(struct soap *soap, const char *tag, int id, _ns1__getAssemblyData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAssemblyData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getAssemblyData ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAssemblyData(struct soap *soap, const char *tag, _ns1__getAssemblyData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getAssemblyData **)soap_malloc(soap, sizeof(_ns1__getAssemblyData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getAssemblyData *)soap_instantiate__ns1__getAssemblyData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getAssemblyData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAssemblyData, sizeof(_ns1__getAssemblyData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAssemblyData(struct soap *soap, _ns1__getAssemblyData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getAssemblyData(soap, tag?tag:"ns1:getAssemblyData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getAssemblyData ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAssemblyData(struct soap *soap, _ns1__getAssemblyData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAssemblyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__staffCheck(struct soap *soap, _ns1__staffCheck *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__staffCheck))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__staffCheck(struct soap *soap, const char *tag, int id, _ns1__staffCheck *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__staffCheck, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__staffCheck ** SOAP_FMAC4 soap_in_PointerTo_ns1__staffCheck(struct soap *soap, const char *tag, _ns1__staffCheck **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__staffCheck **)soap_malloc(soap, sizeof(_ns1__staffCheck *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__staffCheck *)soap_instantiate__ns1__staffCheck(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__staffCheck **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__staffCheck, sizeof(_ns1__staffCheck), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__staffCheck(struct soap *soap, _ns1__staffCheck *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__staffCheck(soap, tag?tag:"ns1:staffCheck", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__staffCheck ** SOAP_FMAC4 soap_get_PointerTo_ns1__staffCheck(struct soap *soap, _ns1__staffCheck **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__staffCheck(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SnSaveTechProcess_USCOREA(struct soap *soap, _ns1__SnSaveTechProcess_USCOREA *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, int id, _ns1__SnSaveTechProcess_USCOREA *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREA ** SOAP_FMAC4 soap_in_PointerTo_ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *tag, _ns1__SnSaveTechProcess_USCOREA **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SnSaveTechProcess_USCOREA **)soap_malloc(soap, sizeof(_ns1__SnSaveTechProcess_USCOREA *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SnSaveTechProcess_USCOREA *)soap_instantiate__ns1__SnSaveTechProcess_USCOREA(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SnSaveTechProcess_USCOREA **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA, sizeof(_ns1__SnSaveTechProcess_USCOREA), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SnSaveTechProcess_USCOREA(struct soap *soap, _ns1__SnSaveTechProcess_USCOREA *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, tag?tag:"ns1:SnSaveTechProcess_A", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess_USCOREA ** SOAP_FMAC4 soap_get_PointerTo_ns1__SnSaveTechProcess_USCOREA(struct soap *soap, _ns1__SnSaveTechProcess_USCOREA **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SnSaveTechProcess_USCOREA(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkSNPangusOrderNo(struct soap *soap, _ns1__checkSNPangusOrderNo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkSNPangusOrderNo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, int id, _ns1__checkSNPangusOrderNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkSNPangusOrderNo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkSNPangusOrderNo(struct soap *soap, const char *tag, _ns1__checkSNPangusOrderNo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkSNPangusOrderNo **)soap_malloc(soap, sizeof(_ns1__checkSNPangusOrderNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkSNPangusOrderNo *)soap_instantiate__ns1__checkSNPangusOrderNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkSNPangusOrderNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkSNPangusOrderNo, sizeof(_ns1__checkSNPangusOrderNo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkSNPangusOrderNo(struct soap *soap, _ns1__checkSNPangusOrderNo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkSNPangusOrderNo(soap, tag?tag:"ns1:checkSNPangusOrderNo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkSNPangusOrderNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkSNPangusOrderNo(struct soap *soap, _ns1__checkSNPangusOrderNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkSNPangusOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__checkSNOrderNo(struct soap *soap, _ns1__checkSNOrderNo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__checkSNOrderNo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__checkSNOrderNo(struct soap *soap, const char *tag, int id, _ns1__checkSNOrderNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__checkSNOrderNo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__checkSNOrderNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__checkSNOrderNo(struct soap *soap, const char *tag, _ns1__checkSNOrderNo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__checkSNOrderNo **)soap_malloc(soap, sizeof(_ns1__checkSNOrderNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__checkSNOrderNo *)soap_instantiate__ns1__checkSNOrderNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__checkSNOrderNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__checkSNOrderNo, sizeof(_ns1__checkSNOrderNo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__checkSNOrderNo(struct soap *soap, _ns1__checkSNOrderNo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__checkSNOrderNo(soap, tag?tag:"ns1:checkSNOrderNo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__checkSNOrderNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__checkSNOrderNo(struct soap *soap, _ns1__checkSNOrderNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__checkSNOrderNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loadNgPanelNo(struct soap *soap, _ns1__loadNgPanelNo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loadNgPanelNo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loadNgPanelNo(struct soap *soap, const char *tag, int id, _ns1__loadNgPanelNo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loadNgPanelNo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loadNgPanelNo ** SOAP_FMAC4 soap_in_PointerTo_ns1__loadNgPanelNo(struct soap *soap, const char *tag, _ns1__loadNgPanelNo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loadNgPanelNo **)soap_malloc(soap, sizeof(_ns1__loadNgPanelNo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loadNgPanelNo *)soap_instantiate__ns1__loadNgPanelNo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__loadNgPanelNo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loadNgPanelNo, sizeof(_ns1__loadNgPanelNo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loadNgPanelNo(struct soap *soap, _ns1__loadNgPanelNo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__loadNgPanelNo(soap, tag?tag:"ns1:loadNgPanelNo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loadNgPanelNo ** SOAP_FMAC4 soap_get_PointerTo_ns1__loadNgPanelNo(struct soap *soap, _ns1__loadNgPanelNo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loadNgPanelNo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loadTimeControlData(struct soap *soap, _ns1__loadTimeControlData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loadTimeControlData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loadTimeControlData(struct soap *soap, const char *tag, int id, _ns1__loadTimeControlData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loadTimeControlData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loadTimeControlData ** SOAP_FMAC4 soap_in_PointerTo_ns1__loadTimeControlData(struct soap *soap, const char *tag, _ns1__loadTimeControlData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loadTimeControlData **)soap_malloc(soap, sizeof(_ns1__loadTimeControlData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loadTimeControlData *)soap_instantiate__ns1__loadTimeControlData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__loadTimeControlData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loadTimeControlData, sizeof(_ns1__loadTimeControlData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loadTimeControlData(struct soap *soap, _ns1__loadTimeControlData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__loadTimeControlData(soap, tag?tag:"ns1:loadTimeControlData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__loadTimeControlData ** SOAP_FMAC4 soap_get_PointerTo_ns1__loadTimeControlData(struct soap *soap, _ns1__loadTimeControlData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loadTimeControlData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__bindAssembly(struct soap *soap, _ns1__bindAssembly *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__bindAssembly))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__bindAssembly(struct soap *soap, const char *tag, int id, _ns1__bindAssembly *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__bindAssembly, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__bindAssembly ** SOAP_FMAC4 soap_in_PointerTo_ns1__bindAssembly(struct soap *soap, const char *tag, _ns1__bindAssembly **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__bindAssembly **)soap_malloc(soap, sizeof(_ns1__bindAssembly *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__bindAssembly *)soap_instantiate__ns1__bindAssembly(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__bindAssembly **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__bindAssembly, sizeof(_ns1__bindAssembly), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__bindAssembly(struct soap *soap, _ns1__bindAssembly *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__bindAssembly(soap, tag?tag:"ns1:bindAssembly", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__bindAssembly ** SOAP_FMAC4 soap_get_PointerTo_ns1__bindAssembly(struct soap *soap, _ns1__bindAssembly **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__bindAssembly(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SnSaveTechProcess(struct soap *soap, _ns1__SnSaveTechProcess *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SnSaveTechProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SnSaveTechProcess(struct soap *soap, const char *tag, int id, _ns1__SnSaveTechProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SnSaveTechProcess, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess ** SOAP_FMAC4 soap_in_PointerTo_ns1__SnSaveTechProcess(struct soap *soap, const char *tag, _ns1__SnSaveTechProcess **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SnSaveTechProcess **)soap_malloc(soap, sizeof(_ns1__SnSaveTechProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SnSaveTechProcess *)soap_instantiate__ns1__SnSaveTechProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SnSaveTechProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SnSaveTechProcess, sizeof(_ns1__SnSaveTechProcess), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SnSaveTechProcess(struct soap *soap, _ns1__SnSaveTechProcess *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SnSaveTechProcess(soap, tag?tag:"ns1:SnSaveTechProcess", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SnSaveTechProcess ** SOAP_FMAC4 soap_get_PointerTo_ns1__SnSaveTechProcess(struct soap *soap, _ns1__SnSaveTechProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SnSaveTechProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
