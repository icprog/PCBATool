/* soapStub.h
   Generated by gSOAP 2.8.31 for WebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://xfire.zxw"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20831
# error "GSOAP VERSION 20831 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _ns1__SnSaveTechProcess;	/* WebService.h:147 */
class _ns1__SnSaveTechProcessResponse;	/* WebService.h:150 */
class _ns1__bindAssembly;	/* WebService.h:153 */
class _ns1__bindAssemblyResponse;	/* WebService.h:156 */
class _ns1__loadTimeControlData;	/* WebService.h:159 */
class _ns1__loadTimeControlDataResponse;	/* WebService.h:162 */
class _ns1__loadNgPanelNo;	/* WebService.h:165 */
class _ns1__loadNgPanelNoResponse;	/* WebService.h:168 */
class _ns1__checkSNOrderNo;	/* WebService.h:171 */
class _ns1__checkSNOrderNoResponse;	/* WebService.h:174 */
class _ns1__checkSNPangusOrderNo;	/* WebService.h:177 */
class _ns1__checkSNPangusOrderNoResponse;	/* WebService.h:180 */
class _ns1__SnSaveTechProcess_USCOREA;	/* WebService.h:183 */
class _ns1__SnSaveTechProcess_USCOREAResponse;	/* WebService.h:186 */
class _ns1__staffCheck;	/* WebService.h:189 */
class _ns1__staffCheckResponse;	/* WebService.h:192 */
class _ns1__getAssemblyData;	/* WebService.h:195 */
class _ns1__getAssemblyDataResponse;	/* WebService.h:198 */
class _ns1__InsertPRateData;	/* WebService.h:201 */
class _ns1__InsertPRateDataResponse;	/* WebService.h:204 */
class _ns1__blakeTestExchangeData1;	/* WebService.h:207 */
class _ns1__blakeTestExchangeData1Response;	/* WebService.h:210 */
class _ns1__InsertTimeControl;	/* WebService.h:213 */
class _ns1__InsertTimeControlResponse;	/* WebService.h:216 */
class _ns1__checkMac;	/* WebService.h:219 */
class _ns1__checkMacResponse;	/* WebService.h:222 */
class _ns1__getMaintanceParm;	/* WebService.h:225 */
class _ns1__getMaintanceParmResponse;	/* WebService.h:228 */
class _ns1__fetchSnCurrentLocation;	/* WebService.h:231 */
class _ns1__fetchSnCurrentLocationResponse;	/* WebService.h:234 */
class _ns1__goNewRouteseq;	/* WebService.h:237 */
class _ns1__goNewRouteseqResponse;	/* WebService.h:240 */
class _ns1__blakeTestExchangeData;	/* WebService.h:243 */
class _ns1__blakeTestExchangeDataResponse;	/* WebService.h:246 */
class _ns1__checkingSNNextRoute;	/* WebService.h:249 */
class _ns1__checkingSNNextRouteResponse;	/* WebService.h:252 */
class _ns1__Ispasspostburnin;	/* WebService.h:255 */
class _ns1__IspasspostburninResponse;	/* WebService.h:258 */
class _ns1__CheckTimeGap;	/* WebService.h:261 */
class _ns1__CheckTimeGapResponse;	/* WebService.h:264 */
struct __ns1__SnSaveTechProcess;	/* WebService.h:1382 */
struct __ns1__bindAssembly;	/* WebService.h:1446 */
struct __ns1__loadTimeControlData;	/* WebService.h:1510 */
struct __ns1__loadNgPanelNo;	/* WebService.h:1574 */
struct __ns1__checkSNOrderNo;	/* WebService.h:1638 */
struct __ns1__checkSNPangusOrderNo;	/* WebService.h:1702 */
struct __ns1__SnSaveTechProcess_USCOREA;	/* WebService.h:1766 */
struct __ns1__staffCheck;	/* WebService.h:1830 */
struct __ns1__getAssemblyData;	/* WebService.h:1894 */
struct __ns1__InsertPRateData;	/* WebService.h:1958 */
struct __ns1__blakeTestExchangeData1;	/* WebService.h:2022 */
struct __ns1__InsertTimeControl;	/* WebService.h:2086 */
struct __ns1__checkMac;	/* WebService.h:2150 */
struct __ns1__getMaintanceParm;	/* WebService.h:2214 */
struct __ns1__fetchSnCurrentLocation;	/* WebService.h:2278 */
struct __ns1__goNewRouteseq;	/* WebService.h:2342 */
struct __ns1__blakeTestExchangeData;	/* WebService.h:2406 */
struct __ns1__checkingSNNextRoute;	/* WebService.h:2470 */
struct __ns1__Ispasspostburnin;	/* WebService.h:2534 */
struct __ns1__CheckTimeGap;	/* WebService.h:2598 */

/* WebService.h:147 */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess
#define SOAP_TYPE__ns1__SnSaveTechProcess (11)
/* complex XSD type 'ns1:SnSaveTechProcess': */
class SOAP_CMAC _ns1__SnSaveTechProcess {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Required element 'ns1:in3' of XSD type 'xsd:string'
        std::string *in3;
        /// Required element 'ns1:in4' of XSD type 'xsd:string'
        std::string *in4;
        /// Required element 'ns1:in5' of XSD type 'xsd:string'
        std::string *in5;
        /// Required element 'ns1:in6' of XSD type 'xsd:string'
        std::string *in6;
        /// Required element 'ns1:in7' of XSD type 'xsd:string'
        std::string *in7;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnSaveTechProcess
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnSaveTechProcess; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnSaveTechProcess, default initialized and not managed by a soap context
        virtual _ns1__SnSaveTechProcess *soap_alloc(void) const { return SOAP_NEW(_ns1__SnSaveTechProcess); }
      public:
        /// Constructor with initializations
        _ns1__SnSaveTechProcess()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          in3 = (std::string *)0;
          in4 = (std::string *)0;
          in5 = (std::string *)0;
          in6 = (std::string *)0;
          in7 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SnSaveTechProcess() { }
        /// Friend allocator used by soap_new__ns1__SnSaveTechProcess(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnSaveTechProcess * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:150 */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcessResponse
#define SOAP_TYPE__ns1__SnSaveTechProcessResponse (12)
/* complex XSD type 'ns1:SnSaveTechProcessResponse': */
class SOAP_CMAC _ns1__SnSaveTechProcessResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnSaveTechProcessResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnSaveTechProcessResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnSaveTechProcessResponse, default initialized and not managed by a soap context
        virtual _ns1__SnSaveTechProcessResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SnSaveTechProcessResponse); }
      public:
        /// Constructor with initializations
        _ns1__SnSaveTechProcessResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SnSaveTechProcessResponse() { }
        /// Friend allocator used by soap_new__ns1__SnSaveTechProcessResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnSaveTechProcessResponse * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcessResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:153 */
#ifndef SOAP_TYPE__ns1__bindAssembly
#define SOAP_TYPE__ns1__bindAssembly (13)
/* complex XSD type 'ns1:bindAssembly': */
class SOAP_CMAC _ns1__bindAssembly {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__bindAssembly
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__bindAssembly; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__bindAssembly, default initialized and not managed by a soap context
        virtual _ns1__bindAssembly *soap_alloc(void) const { return SOAP_NEW(_ns1__bindAssembly); }
      public:
        /// Constructor with initializations
        _ns1__bindAssembly()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__bindAssembly() { }
        /// Friend allocator used by soap_new__ns1__bindAssembly(struct soap*, int)
        friend SOAP_FMAC1 _ns1__bindAssembly * SOAP_FMAC2 soap_instantiate__ns1__bindAssembly(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:156 */
#ifndef SOAP_TYPE__ns1__bindAssemblyResponse
#define SOAP_TYPE__ns1__bindAssemblyResponse (14)
/* complex XSD type 'ns1:bindAssemblyResponse': */
class SOAP_CMAC _ns1__bindAssemblyResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__bindAssemblyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__bindAssemblyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__bindAssemblyResponse, default initialized and not managed by a soap context
        virtual _ns1__bindAssemblyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__bindAssemblyResponse); }
      public:
        /// Constructor with initializations
        _ns1__bindAssemblyResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__bindAssemblyResponse() { }
        /// Friend allocator used by soap_new__ns1__bindAssemblyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__bindAssemblyResponse * SOAP_FMAC2 soap_instantiate__ns1__bindAssemblyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:159 */
#ifndef SOAP_TYPE__ns1__loadTimeControlData
#define SOAP_TYPE__ns1__loadTimeControlData (15)
/* complex XSD type 'ns1:loadTimeControlData': */
class SOAP_CMAC _ns1__loadTimeControlData {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__loadTimeControlData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__loadTimeControlData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__loadTimeControlData, default initialized and not managed by a soap context
        virtual _ns1__loadTimeControlData *soap_alloc(void) const { return SOAP_NEW(_ns1__loadTimeControlData); }
      public:
        /// Constructor with initializations
        _ns1__loadTimeControlData()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__loadTimeControlData() { }
        /// Friend allocator used by soap_new__ns1__loadTimeControlData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__loadTimeControlData * SOAP_FMAC2 soap_instantiate__ns1__loadTimeControlData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:162 */
#ifndef SOAP_TYPE__ns1__loadTimeControlDataResponse
#define SOAP_TYPE__ns1__loadTimeControlDataResponse (16)
/* complex XSD type 'ns1:loadTimeControlDataResponse': */
class SOAP_CMAC _ns1__loadTimeControlDataResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__loadTimeControlDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__loadTimeControlDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__loadTimeControlDataResponse, default initialized and not managed by a soap context
        virtual _ns1__loadTimeControlDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__loadTimeControlDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__loadTimeControlDataResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__loadTimeControlDataResponse() { }
        /// Friend allocator used by soap_new__ns1__loadTimeControlDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__loadTimeControlDataResponse * SOAP_FMAC2 soap_instantiate__ns1__loadTimeControlDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:165 */
#ifndef SOAP_TYPE__ns1__loadNgPanelNo
#define SOAP_TYPE__ns1__loadNgPanelNo (17)
/* complex XSD type 'ns1:loadNgPanelNo': */
class SOAP_CMAC _ns1__loadNgPanelNo {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__loadNgPanelNo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__loadNgPanelNo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__loadNgPanelNo, default initialized and not managed by a soap context
        virtual _ns1__loadNgPanelNo *soap_alloc(void) const { return SOAP_NEW(_ns1__loadNgPanelNo); }
      public:
        /// Constructor with initializations
        _ns1__loadNgPanelNo()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__loadNgPanelNo() { }
        /// Friend allocator used by soap_new__ns1__loadNgPanelNo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__loadNgPanelNo * SOAP_FMAC2 soap_instantiate__ns1__loadNgPanelNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:168 */
#ifndef SOAP_TYPE__ns1__loadNgPanelNoResponse
#define SOAP_TYPE__ns1__loadNgPanelNoResponse (18)
/* complex XSD type 'ns1:loadNgPanelNoResponse': */
class SOAP_CMAC _ns1__loadNgPanelNoResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__loadNgPanelNoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__loadNgPanelNoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__loadNgPanelNoResponse, default initialized and not managed by a soap context
        virtual _ns1__loadNgPanelNoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__loadNgPanelNoResponse); }
      public:
        /// Constructor with initializations
        _ns1__loadNgPanelNoResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__loadNgPanelNoResponse() { }
        /// Friend allocator used by soap_new__ns1__loadNgPanelNoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__loadNgPanelNoResponse * SOAP_FMAC2 soap_instantiate__ns1__loadNgPanelNoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:171 */
#ifndef SOAP_TYPE__ns1__checkSNOrderNo
#define SOAP_TYPE__ns1__checkSNOrderNo (19)
/* complex XSD type 'ns1:checkSNOrderNo': */
class SOAP_CMAC _ns1__checkSNOrderNo {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSNOrderNo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSNOrderNo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSNOrderNo, default initialized and not managed by a soap context
        virtual _ns1__checkSNOrderNo *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSNOrderNo); }
      public:
        /// Constructor with initializations
        _ns1__checkSNOrderNo()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkSNOrderNo() { }
        /// Friend allocator used by soap_new__ns1__checkSNOrderNo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSNOrderNo * SOAP_FMAC2 soap_instantiate__ns1__checkSNOrderNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:174 */
#ifndef SOAP_TYPE__ns1__checkSNOrderNoResponse
#define SOAP_TYPE__ns1__checkSNOrderNoResponse (20)
/* complex XSD type 'ns1:checkSNOrderNoResponse': */
class SOAP_CMAC _ns1__checkSNOrderNoResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSNOrderNoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSNOrderNoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSNOrderNoResponse, default initialized and not managed by a soap context
        virtual _ns1__checkSNOrderNoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSNOrderNoResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkSNOrderNoResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkSNOrderNoResponse() { }
        /// Friend allocator used by soap_new__ns1__checkSNOrderNoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSNOrderNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSNOrderNoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:177 */
#ifndef SOAP_TYPE__ns1__checkSNPangusOrderNo
#define SOAP_TYPE__ns1__checkSNPangusOrderNo (21)
/* complex XSD type 'ns1:checkSNPangusOrderNo': */
class SOAP_CMAC _ns1__checkSNPangusOrderNo {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSNPangusOrderNo
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSNPangusOrderNo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSNPangusOrderNo, default initialized and not managed by a soap context
        virtual _ns1__checkSNPangusOrderNo *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSNPangusOrderNo); }
      public:
        /// Constructor with initializations
        _ns1__checkSNPangusOrderNo()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkSNPangusOrderNo() { }
        /// Friend allocator used by soap_new__ns1__checkSNPangusOrderNo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSNPangusOrderNo * SOAP_FMAC2 soap_instantiate__ns1__checkSNPangusOrderNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:180 */
#ifndef SOAP_TYPE__ns1__checkSNPangusOrderNoResponse
#define SOAP_TYPE__ns1__checkSNPangusOrderNoResponse (22)
/* complex XSD type 'ns1:checkSNPangusOrderNoResponse': */
class SOAP_CMAC _ns1__checkSNPangusOrderNoResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkSNPangusOrderNoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkSNPangusOrderNoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkSNPangusOrderNoResponse, default initialized and not managed by a soap context
        virtual _ns1__checkSNPangusOrderNoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkSNPangusOrderNoResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkSNPangusOrderNoResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkSNPangusOrderNoResponse() { }
        /// Friend allocator used by soap_new__ns1__checkSNPangusOrderNoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkSNPangusOrderNoResponse * SOAP_FMAC2 soap_instantiate__ns1__checkSNPangusOrderNoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:183 */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA
#define SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA (23)
/* complex XSD type 'ns1:SnSaveTechProcess_A': */
class SOAP_CMAC _ns1__SnSaveTechProcess_USCOREA {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Required element 'ns1:in3' of XSD type 'xsd:string'
        std::string *in3;
        /// Required element 'ns1:in4' of XSD type 'xsd:string'
        std::string *in4;
        /// Required element 'ns1:in5' of XSD type 'xsd:string'
        std::string *in5;
        /// Required element 'ns1:in6' of XSD type 'xsd:string'
        std::string *in6;
        /// Required element 'ns1:in7' of XSD type 'xsd:string'
        std::string *in7;
        /// Required element 'ns1:in8' of XSD type 'xsd:string'
        std::string *in8;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnSaveTechProcess_USCOREA, default initialized and not managed by a soap context
        virtual _ns1__SnSaveTechProcess_USCOREA *soap_alloc(void) const { return SOAP_NEW(_ns1__SnSaveTechProcess_USCOREA); }
      public:
        /// Constructor with initializations
        _ns1__SnSaveTechProcess_USCOREA()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          in3 = (std::string *)0;
          in4 = (std::string *)0;
          in5 = (std::string *)0;
          in6 = (std::string *)0;
          in7 = (std::string *)0;
          in8 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SnSaveTechProcess_USCOREA() { }
        /// Friend allocator used by soap_new__ns1__SnSaveTechProcess_USCOREA(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess_USCOREA(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:186 */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse
#define SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse (24)
/* complex XSD type 'ns1:SnSaveTechProcess_AResponse': */
class SOAP_CMAC _ns1__SnSaveTechProcess_USCOREAResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SnSaveTechProcess_USCOREAResponse, default initialized and not managed by a soap context
        virtual _ns1__SnSaveTechProcess_USCOREAResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SnSaveTechProcess_USCOREAResponse); }
      public:
        /// Constructor with initializations
        _ns1__SnSaveTechProcess_USCOREAResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SnSaveTechProcess_USCOREAResponse() { }
        /// Friend allocator used by soap_new__ns1__SnSaveTechProcess_USCOREAResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SnSaveTechProcess_USCOREAResponse * SOAP_FMAC2 soap_instantiate__ns1__SnSaveTechProcess_USCOREAResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:189 */
#ifndef SOAP_TYPE__ns1__staffCheck
#define SOAP_TYPE__ns1__staffCheck (25)
/* complex XSD type 'ns1:staffCheck': */
class SOAP_CMAC _ns1__staffCheck {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__staffCheck
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__staffCheck; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__staffCheck, default initialized and not managed by a soap context
        virtual _ns1__staffCheck *soap_alloc(void) const { return SOAP_NEW(_ns1__staffCheck); }
      public:
        /// Constructor with initializations
        _ns1__staffCheck()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__staffCheck() { }
        /// Friend allocator used by soap_new__ns1__staffCheck(struct soap*, int)
        friend SOAP_FMAC1 _ns1__staffCheck * SOAP_FMAC2 soap_instantiate__ns1__staffCheck(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:192 */
#ifndef SOAP_TYPE__ns1__staffCheckResponse
#define SOAP_TYPE__ns1__staffCheckResponse (26)
/* complex XSD type 'ns1:staffCheckResponse': */
class SOAP_CMAC _ns1__staffCheckResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__staffCheckResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__staffCheckResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__staffCheckResponse, default initialized and not managed by a soap context
        virtual _ns1__staffCheckResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__staffCheckResponse); }
      public:
        /// Constructor with initializations
        _ns1__staffCheckResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__staffCheckResponse() { }
        /// Friend allocator used by soap_new__ns1__staffCheckResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__staffCheckResponse * SOAP_FMAC2 soap_instantiate__ns1__staffCheckResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:195 */
#ifndef SOAP_TYPE__ns1__getAssemblyData
#define SOAP_TYPE__ns1__getAssemblyData (27)
/* complex XSD type 'ns1:getAssemblyData': */
class SOAP_CMAC _ns1__getAssemblyData {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getAssemblyData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getAssemblyData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getAssemblyData, default initialized and not managed by a soap context
        virtual _ns1__getAssemblyData *soap_alloc(void) const { return SOAP_NEW(_ns1__getAssemblyData); }
      public:
        /// Constructor with initializations
        _ns1__getAssemblyData()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getAssemblyData() { }
        /// Friend allocator used by soap_new__ns1__getAssemblyData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getAssemblyData * SOAP_FMAC2 soap_instantiate__ns1__getAssemblyData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:198 */
#ifndef SOAP_TYPE__ns1__getAssemblyDataResponse
#define SOAP_TYPE__ns1__getAssemblyDataResponse (28)
/* complex XSD type 'ns1:getAssemblyDataResponse': */
class SOAP_CMAC _ns1__getAssemblyDataResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getAssemblyDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getAssemblyDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getAssemblyDataResponse, default initialized and not managed by a soap context
        virtual _ns1__getAssemblyDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getAssemblyDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__getAssemblyDataResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getAssemblyDataResponse() { }
        /// Friend allocator used by soap_new__ns1__getAssemblyDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getAssemblyDataResponse * SOAP_FMAC2 soap_instantiate__ns1__getAssemblyDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:201 */
#ifndef SOAP_TYPE__ns1__InsertPRateData
#define SOAP_TYPE__ns1__InsertPRateData (29)
/* complex XSD type 'ns1:InsertPRateData': */
class SOAP_CMAC _ns1__InsertPRateData {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Required element 'ns1:in3' of XSD type 'xsd:string'
        std::string *in3;
        /// Required element 'ns1:in4' of XSD type 'xsd:string'
        std::string *in4;
        /// Required element 'ns1:in5' of XSD type 'xsd:string'
        std::string *in5;
        /// Required element 'ns1:in6' of XSD type 'xsd:string'
        std::string *in6;
        /// Required element 'ns1:in7' of XSD type 'xsd:string'
        std::string *in7;
        /// Required element 'ns1:in8' of XSD type 'xsd:string'
        std::string *in8;
        /// Required element 'ns1:in9' of XSD type 'xsd:string'
        std::string *in9;
        /// Required element 'ns1:in10' of XSD type 'xsd:string'
        std::string *in10;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsertPRateData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsertPRateData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsertPRateData, default initialized and not managed by a soap context
        virtual _ns1__InsertPRateData *soap_alloc(void) const { return SOAP_NEW(_ns1__InsertPRateData); }
      public:
        /// Constructor with initializations
        _ns1__InsertPRateData()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          in3 = (std::string *)0;
          in4 = (std::string *)0;
          in5 = (std::string *)0;
          in6 = (std::string *)0;
          in7 = (std::string *)0;
          in8 = (std::string *)0;
          in9 = (std::string *)0;
          in10 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InsertPRateData() { }
        /// Friend allocator used by soap_new__ns1__InsertPRateData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsertPRateData * SOAP_FMAC2 soap_instantiate__ns1__InsertPRateData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:204 */
#ifndef SOAP_TYPE__ns1__InsertPRateDataResponse
#define SOAP_TYPE__ns1__InsertPRateDataResponse (30)
/* complex XSD type 'ns1:InsertPRateDataResponse': */
class SOAP_CMAC _ns1__InsertPRateDataResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsertPRateDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsertPRateDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsertPRateDataResponse, default initialized and not managed by a soap context
        virtual _ns1__InsertPRateDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsertPRateDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsertPRateDataResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InsertPRateDataResponse() { }
        /// Friend allocator used by soap_new__ns1__InsertPRateDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsertPRateDataResponse * SOAP_FMAC2 soap_instantiate__ns1__InsertPRateDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:207 */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData1
#define SOAP_TYPE__ns1__blakeTestExchangeData1 (31)
/* complex XSD type 'ns1:blakeTestExchangeData1': */
class SOAP_CMAC _ns1__blakeTestExchangeData1 {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Required element 'ns1:in3' of XSD type 'xsd:string'
        std::string *in3;
        /// Required element 'ns1:in4' of XSD type 'xsd:string'
        std::string *in4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__blakeTestExchangeData1
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__blakeTestExchangeData1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__blakeTestExchangeData1, default initialized and not managed by a soap context
        virtual _ns1__blakeTestExchangeData1 *soap_alloc(void) const { return SOAP_NEW(_ns1__blakeTestExchangeData1); }
      public:
        /// Constructor with initializations
        _ns1__blakeTestExchangeData1()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          in3 = (std::string *)0;
          in4 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__blakeTestExchangeData1() { }
        /// Friend allocator used by soap_new__ns1__blakeTestExchangeData1(struct soap*, int)
        friend SOAP_FMAC1 _ns1__blakeTestExchangeData1 * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:210 */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData1Response
#define SOAP_TYPE__ns1__blakeTestExchangeData1Response (32)
/* complex XSD type 'ns1:blakeTestExchangeData1Response': */
class SOAP_CMAC _ns1__blakeTestExchangeData1Response {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__blakeTestExchangeData1Response
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__blakeTestExchangeData1Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__blakeTestExchangeData1Response, default initialized and not managed by a soap context
        virtual _ns1__blakeTestExchangeData1Response *soap_alloc(void) const { return SOAP_NEW(_ns1__blakeTestExchangeData1Response); }
      public:
        /// Constructor with initializations
        _ns1__blakeTestExchangeData1Response()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__blakeTestExchangeData1Response() { }
        /// Friend allocator used by soap_new__ns1__blakeTestExchangeData1Response(struct soap*, int)
        friend SOAP_FMAC1 _ns1__blakeTestExchangeData1Response * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData1Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:213 */
#ifndef SOAP_TYPE__ns1__InsertTimeControl
#define SOAP_TYPE__ns1__InsertTimeControl (33)
/* complex XSD type 'ns1:InsertTimeControl': */
class SOAP_CMAC _ns1__InsertTimeControl {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Required element 'ns1:in3' of XSD type 'xsd:string'
        std::string *in3;
        /// Required element 'ns1:in4' of XSD type 'xsd:string'
        std::string *in4;
        /// Required element 'ns1:in5' of XSD type 'xsd:string'
        std::string *in5;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsertTimeControl
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsertTimeControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsertTimeControl, default initialized and not managed by a soap context
        virtual _ns1__InsertTimeControl *soap_alloc(void) const { return SOAP_NEW(_ns1__InsertTimeControl); }
      public:
        /// Constructor with initializations
        _ns1__InsertTimeControl()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          in3 = (std::string *)0;
          in4 = (std::string *)0;
          in5 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InsertTimeControl() { }
        /// Friend allocator used by soap_new__ns1__InsertTimeControl(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsertTimeControl * SOAP_FMAC2 soap_instantiate__ns1__InsertTimeControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:216 */
#ifndef SOAP_TYPE__ns1__InsertTimeControlResponse
#define SOAP_TYPE__ns1__InsertTimeControlResponse (34)
/* complex XSD type 'ns1:InsertTimeControlResponse': */
class SOAP_CMAC _ns1__InsertTimeControlResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InsertTimeControlResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InsertTimeControlResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InsertTimeControlResponse, default initialized and not managed by a soap context
        virtual _ns1__InsertTimeControlResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InsertTimeControlResponse); }
      public:
        /// Constructor with initializations
        _ns1__InsertTimeControlResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InsertTimeControlResponse() { }
        /// Friend allocator used by soap_new__ns1__InsertTimeControlResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InsertTimeControlResponse * SOAP_FMAC2 soap_instantiate__ns1__InsertTimeControlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:219 */
#ifndef SOAP_TYPE__ns1__checkMac
#define SOAP_TYPE__ns1__checkMac (35)
/* complex XSD type 'ns1:checkMac': */
class SOAP_CMAC _ns1__checkMac {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkMac
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkMac; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkMac, default initialized and not managed by a soap context
        virtual _ns1__checkMac *soap_alloc(void) const { return SOAP_NEW(_ns1__checkMac); }
      public:
        /// Constructor with initializations
        _ns1__checkMac()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkMac() { }
        /// Friend allocator used by soap_new__ns1__checkMac(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkMac * SOAP_FMAC2 soap_instantiate__ns1__checkMac(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:222 */
#ifndef SOAP_TYPE__ns1__checkMacResponse
#define SOAP_TYPE__ns1__checkMacResponse (36)
/* complex XSD type 'ns1:checkMacResponse': */
class SOAP_CMAC _ns1__checkMacResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkMacResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkMacResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkMacResponse, default initialized and not managed by a soap context
        virtual _ns1__checkMacResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkMacResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkMacResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkMacResponse() { }
        /// Friend allocator used by soap_new__ns1__checkMacResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkMacResponse * SOAP_FMAC2 soap_instantiate__ns1__checkMacResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:225 */
#ifndef SOAP_TYPE__ns1__getMaintanceParm
#define SOAP_TYPE__ns1__getMaintanceParm (37)
/* complex XSD type 'ns1:getMaintanceParm': */
class SOAP_CMAC _ns1__getMaintanceParm {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMaintanceParm
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMaintanceParm; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMaintanceParm, default initialized and not managed by a soap context
        virtual _ns1__getMaintanceParm *soap_alloc(void) const { return SOAP_NEW(_ns1__getMaintanceParm); }
      public:
        /// Constructor with initializations
        _ns1__getMaintanceParm()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getMaintanceParm() { }
        /// Friend allocator used by soap_new__ns1__getMaintanceParm(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMaintanceParm * SOAP_FMAC2 soap_instantiate__ns1__getMaintanceParm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:228 */
#ifndef SOAP_TYPE__ns1__getMaintanceParmResponse
#define SOAP_TYPE__ns1__getMaintanceParmResponse (38)
/* complex XSD type 'ns1:getMaintanceParmResponse': */
class SOAP_CMAC _ns1__getMaintanceParmResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getMaintanceParmResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getMaintanceParmResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getMaintanceParmResponse, default initialized and not managed by a soap context
        virtual _ns1__getMaintanceParmResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getMaintanceParmResponse); }
      public:
        /// Constructor with initializations
        _ns1__getMaintanceParmResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getMaintanceParmResponse() { }
        /// Friend allocator used by soap_new__ns1__getMaintanceParmResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getMaintanceParmResponse * SOAP_FMAC2 soap_instantiate__ns1__getMaintanceParmResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:231 */
#ifndef SOAP_TYPE__ns1__fetchSnCurrentLocation
#define SOAP_TYPE__ns1__fetchSnCurrentLocation (39)
/* complex XSD type 'ns1:fetchSnCurrentLocation': */
class SOAP_CMAC _ns1__fetchSnCurrentLocation {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__fetchSnCurrentLocation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__fetchSnCurrentLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__fetchSnCurrentLocation, default initialized and not managed by a soap context
        virtual _ns1__fetchSnCurrentLocation *soap_alloc(void) const { return SOAP_NEW(_ns1__fetchSnCurrentLocation); }
      public:
        /// Constructor with initializations
        _ns1__fetchSnCurrentLocation()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__fetchSnCurrentLocation() { }
        /// Friend allocator used by soap_new__ns1__fetchSnCurrentLocation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__fetchSnCurrentLocation * SOAP_FMAC2 soap_instantiate__ns1__fetchSnCurrentLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:234 */
#ifndef SOAP_TYPE__ns1__fetchSnCurrentLocationResponse
#define SOAP_TYPE__ns1__fetchSnCurrentLocationResponse (40)
/* complex XSD type 'ns1:fetchSnCurrentLocationResponse': */
class SOAP_CMAC _ns1__fetchSnCurrentLocationResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__fetchSnCurrentLocationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__fetchSnCurrentLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__fetchSnCurrentLocationResponse, default initialized and not managed by a soap context
        virtual _ns1__fetchSnCurrentLocationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__fetchSnCurrentLocationResponse); }
      public:
        /// Constructor with initializations
        _ns1__fetchSnCurrentLocationResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__fetchSnCurrentLocationResponse() { }
        /// Friend allocator used by soap_new__ns1__fetchSnCurrentLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__fetchSnCurrentLocationResponse * SOAP_FMAC2 soap_instantiate__ns1__fetchSnCurrentLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:237 */
#ifndef SOAP_TYPE__ns1__goNewRouteseq
#define SOAP_TYPE__ns1__goNewRouteseq (41)
/* complex XSD type 'ns1:goNewRouteseq': */
class SOAP_CMAC _ns1__goNewRouteseq {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__goNewRouteseq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__goNewRouteseq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__goNewRouteseq, default initialized and not managed by a soap context
        virtual _ns1__goNewRouteseq *soap_alloc(void) const { return SOAP_NEW(_ns1__goNewRouteseq); }
      public:
        /// Constructor with initializations
        _ns1__goNewRouteseq()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__goNewRouteseq() { }
        /// Friend allocator used by soap_new__ns1__goNewRouteseq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__goNewRouteseq * SOAP_FMAC2 soap_instantiate__ns1__goNewRouteseq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:240 */
#ifndef SOAP_TYPE__ns1__goNewRouteseqResponse
#define SOAP_TYPE__ns1__goNewRouteseqResponse (42)
/* complex XSD type 'ns1:goNewRouteseqResponse': */
class SOAP_CMAC _ns1__goNewRouteseqResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__goNewRouteseqResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__goNewRouteseqResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__goNewRouteseqResponse, default initialized and not managed by a soap context
        virtual _ns1__goNewRouteseqResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__goNewRouteseqResponse); }
      public:
        /// Constructor with initializations
        _ns1__goNewRouteseqResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__goNewRouteseqResponse() { }
        /// Friend allocator used by soap_new__ns1__goNewRouteseqResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__goNewRouteseqResponse * SOAP_FMAC2 soap_instantiate__ns1__goNewRouteseqResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:243 */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData
#define SOAP_TYPE__ns1__blakeTestExchangeData (43)
/* complex XSD type 'ns1:blakeTestExchangeData': */
class SOAP_CMAC _ns1__blakeTestExchangeData {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__blakeTestExchangeData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__blakeTestExchangeData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__blakeTestExchangeData, default initialized and not managed by a soap context
        virtual _ns1__blakeTestExchangeData *soap_alloc(void) const { return SOAP_NEW(_ns1__blakeTestExchangeData); }
      public:
        /// Constructor with initializations
        _ns1__blakeTestExchangeData()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__blakeTestExchangeData() { }
        /// Friend allocator used by soap_new__ns1__blakeTestExchangeData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__blakeTestExchangeData * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:246 */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeDataResponse
#define SOAP_TYPE__ns1__blakeTestExchangeDataResponse (44)
/* complex XSD type 'ns1:blakeTestExchangeDataResponse': */
class SOAP_CMAC _ns1__blakeTestExchangeDataResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__blakeTestExchangeDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__blakeTestExchangeDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__blakeTestExchangeDataResponse, default initialized and not managed by a soap context
        virtual _ns1__blakeTestExchangeDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__blakeTestExchangeDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__blakeTestExchangeDataResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__blakeTestExchangeDataResponse() { }
        /// Friend allocator used by soap_new__ns1__blakeTestExchangeDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__blakeTestExchangeDataResponse * SOAP_FMAC2 soap_instantiate__ns1__blakeTestExchangeDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:249 */
#ifndef SOAP_TYPE__ns1__checkingSNNextRoute
#define SOAP_TYPE__ns1__checkingSNNextRoute (45)
/* complex XSD type 'ns1:checkingSNNextRoute': */
class SOAP_CMAC _ns1__checkingSNNextRoute {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkingSNNextRoute
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkingSNNextRoute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkingSNNextRoute, default initialized and not managed by a soap context
        virtual _ns1__checkingSNNextRoute *soap_alloc(void) const { return SOAP_NEW(_ns1__checkingSNNextRoute); }
      public:
        /// Constructor with initializations
        _ns1__checkingSNNextRoute()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkingSNNextRoute() { }
        /// Friend allocator used by soap_new__ns1__checkingSNNextRoute(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkingSNNextRoute * SOAP_FMAC2 soap_instantiate__ns1__checkingSNNextRoute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:252 */
#ifndef SOAP_TYPE__ns1__checkingSNNextRouteResponse
#define SOAP_TYPE__ns1__checkingSNNextRouteResponse (46)
/* complex XSD type 'ns1:checkingSNNextRouteResponse': */
class SOAP_CMAC _ns1__checkingSNNextRouteResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__checkingSNNextRouteResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__checkingSNNextRouteResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__checkingSNNextRouteResponse, default initialized and not managed by a soap context
        virtual _ns1__checkingSNNextRouteResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__checkingSNNextRouteResponse); }
      public:
        /// Constructor with initializations
        _ns1__checkingSNNextRouteResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__checkingSNNextRouteResponse() { }
        /// Friend allocator used by soap_new__ns1__checkingSNNextRouteResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__checkingSNNextRouteResponse * SOAP_FMAC2 soap_instantiate__ns1__checkingSNNextRouteResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:255 */
#ifndef SOAP_TYPE__ns1__Ispasspostburnin
#define SOAP_TYPE__ns1__Ispasspostburnin (47)
/* complex XSD type 'ns1:Ispasspostburnin': */
class SOAP_CMAC _ns1__Ispasspostburnin {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Ispasspostburnin
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Ispasspostburnin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Ispasspostburnin, default initialized and not managed by a soap context
        virtual _ns1__Ispasspostburnin *soap_alloc(void) const { return SOAP_NEW(_ns1__Ispasspostburnin); }
      public:
        /// Constructor with initializations
        _ns1__Ispasspostburnin()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Ispasspostburnin() { }
        /// Friend allocator used by soap_new__ns1__Ispasspostburnin(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Ispasspostburnin * SOAP_FMAC2 soap_instantiate__ns1__Ispasspostburnin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:258 */
#ifndef SOAP_TYPE__ns1__IspasspostburninResponse
#define SOAP_TYPE__ns1__IspasspostburninResponse (48)
/* complex XSD type 'ns1:IspasspostburninResponse': */
class SOAP_CMAC _ns1__IspasspostburninResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:int'
        int out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__IspasspostburninResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__IspasspostburninResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__IspasspostburninResponse, default initialized and not managed by a soap context
        virtual _ns1__IspasspostburninResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__IspasspostburninResponse); }
      public:
        /// Constructor with initializations
        _ns1__IspasspostburninResponse()
        {
          out = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__IspasspostburninResponse() { }
        /// Friend allocator used by soap_new__ns1__IspasspostburninResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__IspasspostburninResponse * SOAP_FMAC2 soap_instantiate__ns1__IspasspostburninResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:261 */
#ifndef SOAP_TYPE__ns1__CheckTimeGap
#define SOAP_TYPE__ns1__CheckTimeGap (49)
/* complex XSD type 'ns1:CheckTimeGap': */
class SOAP_CMAC _ns1__CheckTimeGap {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckTimeGap
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CheckTimeGap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckTimeGap, default initialized and not managed by a soap context
        virtual _ns1__CheckTimeGap *soap_alloc(void) const { return SOAP_NEW(_ns1__CheckTimeGap); }
      public:
        /// Constructor with initializations
        _ns1__CheckTimeGap()
        {
          in0 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CheckTimeGap() { }
        /// Friend allocator used by soap_new__ns1__CheckTimeGap(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckTimeGap * SOAP_FMAC2 soap_instantiate__ns1__CheckTimeGap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:264 */
#ifndef SOAP_TYPE__ns1__CheckTimeGapResponse
#define SOAP_TYPE__ns1__CheckTimeGapResponse (50)
/* complex XSD type 'ns1:CheckTimeGapResponse': */
class SOAP_CMAC _ns1__CheckTimeGapResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckTimeGapResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CheckTimeGapResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckTimeGapResponse, default initialized and not managed by a soap context
        virtual _ns1__CheckTimeGapResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CheckTimeGapResponse); }
      public:
        /// Constructor with initializations
        _ns1__CheckTimeGapResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CheckTimeGapResponse() { }
        /// Friend allocator used by soap_new__ns1__CheckTimeGapResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckTimeGapResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckTimeGapResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1382 */
#ifndef SOAP_TYPE___ns1__SnSaveTechProcess
#define SOAP_TYPE___ns1__SnSaveTechProcess (57)
/* Wrapper: */
struct __ns1__SnSaveTechProcess {
      public:
        /** Optional element 'ns1:SnSaveTechProcess' of XSD type 'ns1:SnSaveTechProcess' */
        _ns1__SnSaveTechProcess *ns1__SnSaveTechProcess;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnSaveTechProcess */
        int soap_type() const { return SOAP_TYPE___ns1__SnSaveTechProcess; }
        /** Constructor with member initializations */
        __ns1__SnSaveTechProcess()
        {
          ns1__SnSaveTechProcess = (_ns1__SnSaveTechProcess *)0;
        }
        /** Friend allocator used by soap_new___ns1__SnSaveTechProcess(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SnSaveTechProcess * SOAP_FMAC2 soap_instantiate___ns1__SnSaveTechProcess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1446 */
#ifndef SOAP_TYPE___ns1__bindAssembly
#define SOAP_TYPE___ns1__bindAssembly (61)
/* Wrapper: */
struct __ns1__bindAssembly {
      public:
        /** Optional element 'ns1:bindAssembly' of XSD type 'ns1:bindAssembly' */
        _ns1__bindAssembly *ns1__bindAssembly;
      public:
        /** Return unique type id SOAP_TYPE___ns1__bindAssembly */
        int soap_type() const { return SOAP_TYPE___ns1__bindAssembly; }
        /** Constructor with member initializations */
        __ns1__bindAssembly()
        {
          ns1__bindAssembly = (_ns1__bindAssembly *)0;
        }
        /** Friend allocator used by soap_new___ns1__bindAssembly(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__bindAssembly * SOAP_FMAC2 soap_instantiate___ns1__bindAssembly(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1510 */
#ifndef SOAP_TYPE___ns1__loadTimeControlData
#define SOAP_TYPE___ns1__loadTimeControlData (65)
/* Wrapper: */
struct __ns1__loadTimeControlData {
      public:
        /** Optional element 'ns1:loadTimeControlData' of XSD type 'ns1:loadTimeControlData' */
        _ns1__loadTimeControlData *ns1__loadTimeControlData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__loadTimeControlData */
        int soap_type() const { return SOAP_TYPE___ns1__loadTimeControlData; }
        /** Constructor with member initializations */
        __ns1__loadTimeControlData()
        {
          ns1__loadTimeControlData = (_ns1__loadTimeControlData *)0;
        }
        /** Friend allocator used by soap_new___ns1__loadTimeControlData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__loadTimeControlData * SOAP_FMAC2 soap_instantiate___ns1__loadTimeControlData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1574 */
#ifndef SOAP_TYPE___ns1__loadNgPanelNo
#define SOAP_TYPE___ns1__loadNgPanelNo (69)
/* Wrapper: */
struct __ns1__loadNgPanelNo {
      public:
        /** Optional element 'ns1:loadNgPanelNo' of XSD type 'ns1:loadNgPanelNo' */
        _ns1__loadNgPanelNo *ns1__loadNgPanelNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__loadNgPanelNo */
        int soap_type() const { return SOAP_TYPE___ns1__loadNgPanelNo; }
        /** Constructor with member initializations */
        __ns1__loadNgPanelNo()
        {
          ns1__loadNgPanelNo = (_ns1__loadNgPanelNo *)0;
        }
        /** Friend allocator used by soap_new___ns1__loadNgPanelNo(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__loadNgPanelNo * SOAP_FMAC2 soap_instantiate___ns1__loadNgPanelNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1638 */
#ifndef SOAP_TYPE___ns1__checkSNOrderNo
#define SOAP_TYPE___ns1__checkSNOrderNo (73)
/* Wrapper: */
struct __ns1__checkSNOrderNo {
      public:
        /** Optional element 'ns1:checkSNOrderNo' of XSD type 'ns1:checkSNOrderNo' */
        _ns1__checkSNOrderNo *ns1__checkSNOrderNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSNOrderNo */
        int soap_type() const { return SOAP_TYPE___ns1__checkSNOrderNo; }
        /** Constructor with member initializations */
        __ns1__checkSNOrderNo()
        {
          ns1__checkSNOrderNo = (_ns1__checkSNOrderNo *)0;
        }
        /** Friend allocator used by soap_new___ns1__checkSNOrderNo(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__checkSNOrderNo * SOAP_FMAC2 soap_instantiate___ns1__checkSNOrderNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1702 */
#ifndef SOAP_TYPE___ns1__checkSNPangusOrderNo
#define SOAP_TYPE___ns1__checkSNPangusOrderNo (77)
/* Wrapper: */
struct __ns1__checkSNPangusOrderNo {
      public:
        /** Optional element 'ns1:checkSNPangusOrderNo' of XSD type 'ns1:checkSNPangusOrderNo' */
        _ns1__checkSNPangusOrderNo *ns1__checkSNPangusOrderNo;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkSNPangusOrderNo */
        int soap_type() const { return SOAP_TYPE___ns1__checkSNPangusOrderNo; }
        /** Constructor with member initializations */
        __ns1__checkSNPangusOrderNo()
        {
          ns1__checkSNPangusOrderNo = (_ns1__checkSNPangusOrderNo *)0;
        }
        /** Friend allocator used by soap_new___ns1__checkSNPangusOrderNo(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__checkSNPangusOrderNo * SOAP_FMAC2 soap_instantiate___ns1__checkSNPangusOrderNo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1766 */
#ifndef SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA
#define SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA (81)
/* Wrapper: */
struct __ns1__SnSaveTechProcess_USCOREA {
      public:
        /** Optional element 'ns1:SnSaveTechProcess_A' of XSD type 'ns1:SnSaveTechProcess_A' */
        _ns1__SnSaveTechProcess_USCOREA *ns1__SnSaveTechProcess_USCOREA;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA */
        int soap_type() const { return SOAP_TYPE___ns1__SnSaveTechProcess_USCOREA; }
        /** Constructor with member initializations */
        __ns1__SnSaveTechProcess_USCOREA()
        {
          ns1__SnSaveTechProcess_USCOREA = (_ns1__SnSaveTechProcess_USCOREA *)0;
        }
        /** Friend allocator used by soap_new___ns1__SnSaveTechProcess_USCOREA(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SnSaveTechProcess_USCOREA * SOAP_FMAC2 soap_instantiate___ns1__SnSaveTechProcess_USCOREA(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1830 */
#ifndef SOAP_TYPE___ns1__staffCheck
#define SOAP_TYPE___ns1__staffCheck (85)
/* Wrapper: */
struct __ns1__staffCheck {
      public:
        /** Optional element 'ns1:staffCheck' of XSD type 'ns1:staffCheck' */
        _ns1__staffCheck *ns1__staffCheck;
      public:
        /** Return unique type id SOAP_TYPE___ns1__staffCheck */
        int soap_type() const { return SOAP_TYPE___ns1__staffCheck; }
        /** Constructor with member initializations */
        __ns1__staffCheck()
        {
          ns1__staffCheck = (_ns1__staffCheck *)0;
        }
        /** Friend allocator used by soap_new___ns1__staffCheck(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__staffCheck * SOAP_FMAC2 soap_instantiate___ns1__staffCheck(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1894 */
#ifndef SOAP_TYPE___ns1__getAssemblyData
#define SOAP_TYPE___ns1__getAssemblyData (89)
/* Wrapper: */
struct __ns1__getAssemblyData {
      public:
        /** Optional element 'ns1:getAssemblyData' of XSD type 'ns1:getAssemblyData' */
        _ns1__getAssemblyData *ns1__getAssemblyData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getAssemblyData */
        int soap_type() const { return SOAP_TYPE___ns1__getAssemblyData; }
        /** Constructor with member initializations */
        __ns1__getAssemblyData()
        {
          ns1__getAssemblyData = (_ns1__getAssemblyData *)0;
        }
        /** Friend allocator used by soap_new___ns1__getAssemblyData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getAssemblyData * SOAP_FMAC2 soap_instantiate___ns1__getAssemblyData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:1958 */
#ifndef SOAP_TYPE___ns1__InsertPRateData
#define SOAP_TYPE___ns1__InsertPRateData (93)
/* Wrapper: */
struct __ns1__InsertPRateData {
      public:
        /** Optional element 'ns1:InsertPRateData' of XSD type 'ns1:InsertPRateData' */
        _ns1__InsertPRateData *ns1__InsertPRateData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsertPRateData */
        int soap_type() const { return SOAP_TYPE___ns1__InsertPRateData; }
        /** Constructor with member initializations */
        __ns1__InsertPRateData()
        {
          ns1__InsertPRateData = (_ns1__InsertPRateData *)0;
        }
        /** Friend allocator used by soap_new___ns1__InsertPRateData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__InsertPRateData * SOAP_FMAC2 soap_instantiate___ns1__InsertPRateData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2022 */
#ifndef SOAP_TYPE___ns1__blakeTestExchangeData1
#define SOAP_TYPE___ns1__blakeTestExchangeData1 (97)
/* Wrapper: */
struct __ns1__blakeTestExchangeData1 {
      public:
        /** Optional element 'ns1:blakeTestExchangeData1' of XSD type 'ns1:blakeTestExchangeData1' */
        _ns1__blakeTestExchangeData1 *ns1__blakeTestExchangeData1;
      public:
        /** Return unique type id SOAP_TYPE___ns1__blakeTestExchangeData1 */
        int soap_type() const { return SOAP_TYPE___ns1__blakeTestExchangeData1; }
        /** Constructor with member initializations */
        __ns1__blakeTestExchangeData1()
        {
          ns1__blakeTestExchangeData1 = (_ns1__blakeTestExchangeData1 *)0;
        }
        /** Friend allocator used by soap_new___ns1__blakeTestExchangeData1(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__blakeTestExchangeData1 * SOAP_FMAC2 soap_instantiate___ns1__blakeTestExchangeData1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2086 */
#ifndef SOAP_TYPE___ns1__InsertTimeControl
#define SOAP_TYPE___ns1__InsertTimeControl (101)
/* Wrapper: */
struct __ns1__InsertTimeControl {
      public:
        /** Optional element 'ns1:InsertTimeControl' of XSD type 'ns1:InsertTimeControl' */
        _ns1__InsertTimeControl *ns1__InsertTimeControl;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InsertTimeControl */
        int soap_type() const { return SOAP_TYPE___ns1__InsertTimeControl; }
        /** Constructor with member initializations */
        __ns1__InsertTimeControl()
        {
          ns1__InsertTimeControl = (_ns1__InsertTimeControl *)0;
        }
        /** Friend allocator used by soap_new___ns1__InsertTimeControl(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__InsertTimeControl * SOAP_FMAC2 soap_instantiate___ns1__InsertTimeControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2150 */
#ifndef SOAP_TYPE___ns1__checkMac
#define SOAP_TYPE___ns1__checkMac (105)
/* Wrapper: */
struct __ns1__checkMac {
      public:
        /** Optional element 'ns1:checkMac' of XSD type 'ns1:checkMac' */
        _ns1__checkMac *ns1__checkMac;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkMac */
        int soap_type() const { return SOAP_TYPE___ns1__checkMac; }
        /** Constructor with member initializations */
        __ns1__checkMac()
        {
          ns1__checkMac = (_ns1__checkMac *)0;
        }
        /** Friend allocator used by soap_new___ns1__checkMac(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__checkMac * SOAP_FMAC2 soap_instantiate___ns1__checkMac(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2214 */
#ifndef SOAP_TYPE___ns1__getMaintanceParm
#define SOAP_TYPE___ns1__getMaintanceParm (109)
/* Wrapper: */
struct __ns1__getMaintanceParm {
      public:
        /** Optional element 'ns1:getMaintanceParm' of XSD type 'ns1:getMaintanceParm' */
        _ns1__getMaintanceParm *ns1__getMaintanceParm;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMaintanceParm */
        int soap_type() const { return SOAP_TYPE___ns1__getMaintanceParm; }
        /** Constructor with member initializations */
        __ns1__getMaintanceParm()
        {
          ns1__getMaintanceParm = (_ns1__getMaintanceParm *)0;
        }
        /** Friend allocator used by soap_new___ns1__getMaintanceParm(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getMaintanceParm * SOAP_FMAC2 soap_instantiate___ns1__getMaintanceParm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2278 */
#ifndef SOAP_TYPE___ns1__fetchSnCurrentLocation
#define SOAP_TYPE___ns1__fetchSnCurrentLocation (113)
/* Wrapper: */
struct __ns1__fetchSnCurrentLocation {
      public:
        /** Optional element 'ns1:fetchSnCurrentLocation' of XSD type 'ns1:fetchSnCurrentLocation' */
        _ns1__fetchSnCurrentLocation *ns1__fetchSnCurrentLocation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__fetchSnCurrentLocation */
        int soap_type() const { return SOAP_TYPE___ns1__fetchSnCurrentLocation; }
        /** Constructor with member initializations */
        __ns1__fetchSnCurrentLocation()
        {
          ns1__fetchSnCurrentLocation = (_ns1__fetchSnCurrentLocation *)0;
        }
        /** Friend allocator used by soap_new___ns1__fetchSnCurrentLocation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__fetchSnCurrentLocation * SOAP_FMAC2 soap_instantiate___ns1__fetchSnCurrentLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2342 */
#ifndef SOAP_TYPE___ns1__goNewRouteseq
#define SOAP_TYPE___ns1__goNewRouteseq (117)
/* Wrapper: */
struct __ns1__goNewRouteseq {
      public:
        /** Optional element 'ns1:goNewRouteseq' of XSD type 'ns1:goNewRouteseq' */
        _ns1__goNewRouteseq *ns1__goNewRouteseq;
      public:
        /** Return unique type id SOAP_TYPE___ns1__goNewRouteseq */
        int soap_type() const { return SOAP_TYPE___ns1__goNewRouteseq; }
        /** Constructor with member initializations */
        __ns1__goNewRouteseq()
        {
          ns1__goNewRouteseq = (_ns1__goNewRouteseq *)0;
        }
        /** Friend allocator used by soap_new___ns1__goNewRouteseq(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__goNewRouteseq * SOAP_FMAC2 soap_instantiate___ns1__goNewRouteseq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2406 */
#ifndef SOAP_TYPE___ns1__blakeTestExchangeData
#define SOAP_TYPE___ns1__blakeTestExchangeData (121)
/* Wrapper: */
struct __ns1__blakeTestExchangeData {
      public:
        /** Optional element 'ns1:blakeTestExchangeData' of XSD type 'ns1:blakeTestExchangeData' */
        _ns1__blakeTestExchangeData *ns1__blakeTestExchangeData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__blakeTestExchangeData */
        int soap_type() const { return SOAP_TYPE___ns1__blakeTestExchangeData; }
        /** Constructor with member initializations */
        __ns1__blakeTestExchangeData()
        {
          ns1__blakeTestExchangeData = (_ns1__blakeTestExchangeData *)0;
        }
        /** Friend allocator used by soap_new___ns1__blakeTestExchangeData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__blakeTestExchangeData * SOAP_FMAC2 soap_instantiate___ns1__blakeTestExchangeData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2470 */
#ifndef SOAP_TYPE___ns1__checkingSNNextRoute
#define SOAP_TYPE___ns1__checkingSNNextRoute (125)
/* Wrapper: */
struct __ns1__checkingSNNextRoute {
      public:
        /** Optional element 'ns1:checkingSNNextRoute' of XSD type 'ns1:checkingSNNextRoute' */
        _ns1__checkingSNNextRoute *ns1__checkingSNNextRoute;
      public:
        /** Return unique type id SOAP_TYPE___ns1__checkingSNNextRoute */
        int soap_type() const { return SOAP_TYPE___ns1__checkingSNNextRoute; }
        /** Constructor with member initializations */
        __ns1__checkingSNNextRoute()
        {
          ns1__checkingSNNextRoute = (_ns1__checkingSNNextRoute *)0;
        }
        /** Friend allocator used by soap_new___ns1__checkingSNNextRoute(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__checkingSNNextRoute * SOAP_FMAC2 soap_instantiate___ns1__checkingSNNextRoute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2534 */
#ifndef SOAP_TYPE___ns1__Ispasspostburnin
#define SOAP_TYPE___ns1__Ispasspostburnin (129)
/* Wrapper: */
struct __ns1__Ispasspostburnin {
      public:
        /** Optional element 'ns1:Ispasspostburnin' of XSD type 'ns1:Ispasspostburnin' */
        _ns1__Ispasspostburnin *ns1__Ispasspostburnin;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Ispasspostburnin */
        int soap_type() const { return SOAP_TYPE___ns1__Ispasspostburnin; }
        /** Constructor with member initializations */
        __ns1__Ispasspostburnin()
        {
          ns1__Ispasspostburnin = (_ns1__Ispasspostburnin *)0;
        }
        /** Friend allocator used by soap_new___ns1__Ispasspostburnin(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Ispasspostburnin * SOAP_FMAC2 soap_instantiate___ns1__Ispasspostburnin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2598 */
#ifndef SOAP_TYPE___ns1__CheckTimeGap
#define SOAP_TYPE___ns1__CheckTimeGap (133)
/* Wrapper: */
struct __ns1__CheckTimeGap {
      public:
        /** Optional element 'ns1:CheckTimeGap' of XSD type 'ns1:CheckTimeGap' */
        _ns1__CheckTimeGap *ns1__CheckTimeGap;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CheckTimeGap */
        int soap_type() const { return SOAP_TYPE___ns1__CheckTimeGap; }
        /** Constructor with member initializations */
        __ns1__CheckTimeGap()
        {
          ns1__CheckTimeGap = (_ns1__CheckTimeGap *)0;
        }
        /** Friend allocator used by soap_new___ns1__CheckTimeGap(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CheckTimeGap * SOAP_FMAC2 soap_instantiate___ns1__CheckTimeGap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WebService.h:2979 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (134)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:2979 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (135)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:2979 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (137)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:2979 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (140)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WebService.h:2979 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (141)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* WebService.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* WebService.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (51)
#endif

/* _ns1__CheckTimeGapResponse has binding name '_ns1__CheckTimeGapResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CheckTimeGapResponse
#define SOAP_TYPE__ns1__CheckTimeGapResponse (50)
#endif

/* _ns1__CheckTimeGap has binding name '_ns1__CheckTimeGap' for type '' */
#ifndef SOAP_TYPE__ns1__CheckTimeGap
#define SOAP_TYPE__ns1__CheckTimeGap (49)
#endif

/* _ns1__IspasspostburninResponse has binding name '_ns1__IspasspostburninResponse' for type '' */
#ifndef SOAP_TYPE__ns1__IspasspostburninResponse
#define SOAP_TYPE__ns1__IspasspostburninResponse (48)
#endif

/* _ns1__Ispasspostburnin has binding name '_ns1__Ispasspostburnin' for type '' */
#ifndef SOAP_TYPE__ns1__Ispasspostburnin
#define SOAP_TYPE__ns1__Ispasspostburnin (47)
#endif

/* _ns1__checkingSNNextRouteResponse has binding name '_ns1__checkingSNNextRouteResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkingSNNextRouteResponse
#define SOAP_TYPE__ns1__checkingSNNextRouteResponse (46)
#endif

/* _ns1__checkingSNNextRoute has binding name '_ns1__checkingSNNextRoute' for type '' */
#ifndef SOAP_TYPE__ns1__checkingSNNextRoute
#define SOAP_TYPE__ns1__checkingSNNextRoute (45)
#endif

/* _ns1__blakeTestExchangeDataResponse has binding name '_ns1__blakeTestExchangeDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeDataResponse
#define SOAP_TYPE__ns1__blakeTestExchangeDataResponse (44)
#endif

/* _ns1__blakeTestExchangeData has binding name '_ns1__blakeTestExchangeData' for type '' */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData
#define SOAP_TYPE__ns1__blakeTestExchangeData (43)
#endif

/* _ns1__goNewRouteseqResponse has binding name '_ns1__goNewRouteseqResponse' for type '' */
#ifndef SOAP_TYPE__ns1__goNewRouteseqResponse
#define SOAP_TYPE__ns1__goNewRouteseqResponse (42)
#endif

/* _ns1__goNewRouteseq has binding name '_ns1__goNewRouteseq' for type '' */
#ifndef SOAP_TYPE__ns1__goNewRouteseq
#define SOAP_TYPE__ns1__goNewRouteseq (41)
#endif

/* _ns1__fetchSnCurrentLocationResponse has binding name '_ns1__fetchSnCurrentLocationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__fetchSnCurrentLocationResponse
#define SOAP_TYPE__ns1__fetchSnCurrentLocationResponse (40)
#endif

/* _ns1__fetchSnCurrentLocation has binding name '_ns1__fetchSnCurrentLocation' for type '' */
#ifndef SOAP_TYPE__ns1__fetchSnCurrentLocation
#define SOAP_TYPE__ns1__fetchSnCurrentLocation (39)
#endif

/* _ns1__getMaintanceParmResponse has binding name '_ns1__getMaintanceParmResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getMaintanceParmResponse
#define SOAP_TYPE__ns1__getMaintanceParmResponse (38)
#endif

/* _ns1__getMaintanceParm has binding name '_ns1__getMaintanceParm' for type '' */
#ifndef SOAP_TYPE__ns1__getMaintanceParm
#define SOAP_TYPE__ns1__getMaintanceParm (37)
#endif

/* _ns1__checkMacResponse has binding name '_ns1__checkMacResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkMacResponse
#define SOAP_TYPE__ns1__checkMacResponse (36)
#endif

/* _ns1__checkMac has binding name '_ns1__checkMac' for type '' */
#ifndef SOAP_TYPE__ns1__checkMac
#define SOAP_TYPE__ns1__checkMac (35)
#endif

/* _ns1__InsertTimeControlResponse has binding name '_ns1__InsertTimeControlResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsertTimeControlResponse
#define SOAP_TYPE__ns1__InsertTimeControlResponse (34)
#endif

/* _ns1__InsertTimeControl has binding name '_ns1__InsertTimeControl' for type '' */
#ifndef SOAP_TYPE__ns1__InsertTimeControl
#define SOAP_TYPE__ns1__InsertTimeControl (33)
#endif

/* _ns1__blakeTestExchangeData1Response has binding name '_ns1__blakeTestExchangeData1Response' for type '' */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData1Response
#define SOAP_TYPE__ns1__blakeTestExchangeData1Response (32)
#endif

/* _ns1__blakeTestExchangeData1 has binding name '_ns1__blakeTestExchangeData1' for type '' */
#ifndef SOAP_TYPE__ns1__blakeTestExchangeData1
#define SOAP_TYPE__ns1__blakeTestExchangeData1 (31)
#endif

/* _ns1__InsertPRateDataResponse has binding name '_ns1__InsertPRateDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InsertPRateDataResponse
#define SOAP_TYPE__ns1__InsertPRateDataResponse (30)
#endif

/* _ns1__InsertPRateData has binding name '_ns1__InsertPRateData' for type '' */
#ifndef SOAP_TYPE__ns1__InsertPRateData
#define SOAP_TYPE__ns1__InsertPRateData (29)
#endif

/* _ns1__getAssemblyDataResponse has binding name '_ns1__getAssemblyDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getAssemblyDataResponse
#define SOAP_TYPE__ns1__getAssemblyDataResponse (28)
#endif

/* _ns1__getAssemblyData has binding name '_ns1__getAssemblyData' for type '' */
#ifndef SOAP_TYPE__ns1__getAssemblyData
#define SOAP_TYPE__ns1__getAssemblyData (27)
#endif

/* _ns1__staffCheckResponse has binding name '_ns1__staffCheckResponse' for type '' */
#ifndef SOAP_TYPE__ns1__staffCheckResponse
#define SOAP_TYPE__ns1__staffCheckResponse (26)
#endif

/* _ns1__staffCheck has binding name '_ns1__staffCheck' for type '' */
#ifndef SOAP_TYPE__ns1__staffCheck
#define SOAP_TYPE__ns1__staffCheck (25)
#endif

/* _ns1__SnSaveTechProcess_USCOREAResponse has binding name '_ns1__SnSaveTechProcess_USCOREAResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse
#define SOAP_TYPE__ns1__SnSaveTechProcess_USCOREAResponse (24)
#endif

/* _ns1__SnSaveTechProcess_USCOREA has binding name '_ns1__SnSaveTechProcess_USCOREA' for type '' */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA
#define SOAP_TYPE__ns1__SnSaveTechProcess_USCOREA (23)
#endif

/* _ns1__checkSNPangusOrderNoResponse has binding name '_ns1__checkSNPangusOrderNoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkSNPangusOrderNoResponse
#define SOAP_TYPE__ns1__checkSNPangusOrderNoResponse (22)
#endif

/* _ns1__checkSNPangusOrderNo has binding name '_ns1__checkSNPangusOrderNo' for type '' */
#ifndef SOAP_TYPE__ns1__checkSNPangusOrderNo
#define SOAP_TYPE__ns1__checkSNPangusOrderNo (21)
#endif

/* _ns1__checkSNOrderNoResponse has binding name '_ns1__checkSNOrderNoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__checkSNOrderNoResponse
#define SOAP_TYPE__ns1__checkSNOrderNoResponse (20)
#endif

/* _ns1__checkSNOrderNo has binding name '_ns1__checkSNOrderNo' for type '' */
#ifndef SOAP_TYPE__ns1__checkSNOrderNo
#define SOAP_TYPE__ns1__checkSNOrderNo (19)
#endif

/* _ns1__loadNgPanelNoResponse has binding name '_ns1__loadNgPanelNoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__loadNgPanelNoResponse
#define SOAP_TYPE__ns1__loadNgPanelNoResponse (18)
#endif

/* _ns1__loadNgPanelNo has binding name '_ns1__loadNgPanelNo' for type '' */
#ifndef SOAP_TYPE__ns1__loadNgPanelNo
#define SOAP_TYPE__ns1__loadNgPanelNo (17)
#endif

/* _ns1__loadTimeControlDataResponse has binding name '_ns1__loadTimeControlDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__loadTimeControlDataResponse
#define SOAP_TYPE__ns1__loadTimeControlDataResponse (16)
#endif

/* _ns1__loadTimeControlData has binding name '_ns1__loadTimeControlData' for type '' */
#ifndef SOAP_TYPE__ns1__loadTimeControlData
#define SOAP_TYPE__ns1__loadTimeControlData (15)
#endif

/* _ns1__bindAssemblyResponse has binding name '_ns1__bindAssemblyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__bindAssemblyResponse
#define SOAP_TYPE__ns1__bindAssemblyResponse (14)
#endif

/* _ns1__bindAssembly has binding name '_ns1__bindAssembly' for type '' */
#ifndef SOAP_TYPE__ns1__bindAssembly
#define SOAP_TYPE__ns1__bindAssembly (13)
#endif

/* _ns1__SnSaveTechProcessResponse has binding name '_ns1__SnSaveTechProcessResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcessResponse
#define SOAP_TYPE__ns1__SnSaveTechProcessResponse (12)
#endif

/* _ns1__SnSaveTechProcess has binding name '_ns1__SnSaveTechProcess' for type '' */
#ifndef SOAP_TYPE__ns1__SnSaveTechProcess
#define SOAP_TYPE__ns1__SnSaveTechProcess (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (141)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (140)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (137)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (135)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (134)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (143)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (142)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (136)
#endif

/* _ns1__CheckTimeGap * has binding name 'PointerTo_ns1__CheckTimeGap' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CheckTimeGap
#define SOAP_TYPE_PointerTo_ns1__CheckTimeGap (130)
#endif

/* _ns1__Ispasspostburnin * has binding name 'PointerTo_ns1__Ispasspostburnin' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Ispasspostburnin
#define SOAP_TYPE_PointerTo_ns1__Ispasspostburnin (126)
#endif

/* _ns1__checkingSNNextRoute * has binding name 'PointerTo_ns1__checkingSNNextRoute' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkingSNNextRoute
#define SOAP_TYPE_PointerTo_ns1__checkingSNNextRoute (122)
#endif

/* _ns1__blakeTestExchangeData * has binding name 'PointerTo_ns1__blakeTestExchangeData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData
#define SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData (118)
#endif

/* _ns1__goNewRouteseq * has binding name 'PointerTo_ns1__goNewRouteseq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__goNewRouteseq
#define SOAP_TYPE_PointerTo_ns1__goNewRouteseq (114)
#endif

/* _ns1__fetchSnCurrentLocation * has binding name 'PointerTo_ns1__fetchSnCurrentLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__fetchSnCurrentLocation
#define SOAP_TYPE_PointerTo_ns1__fetchSnCurrentLocation (110)
#endif

/* _ns1__getMaintanceParm * has binding name 'PointerTo_ns1__getMaintanceParm' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getMaintanceParm
#define SOAP_TYPE_PointerTo_ns1__getMaintanceParm (106)
#endif

/* _ns1__checkMac * has binding name 'PointerTo_ns1__checkMac' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkMac
#define SOAP_TYPE_PointerTo_ns1__checkMac (102)
#endif

/* _ns1__InsertTimeControl * has binding name 'PointerTo_ns1__InsertTimeControl' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsertTimeControl
#define SOAP_TYPE_PointerTo_ns1__InsertTimeControl (98)
#endif

/* _ns1__blakeTestExchangeData1 * has binding name 'PointerTo_ns1__blakeTestExchangeData1' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData1
#define SOAP_TYPE_PointerTo_ns1__blakeTestExchangeData1 (94)
#endif

/* _ns1__InsertPRateData * has binding name 'PointerTo_ns1__InsertPRateData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InsertPRateData
#define SOAP_TYPE_PointerTo_ns1__InsertPRateData (90)
#endif

/* _ns1__getAssemblyData * has binding name 'PointerTo_ns1__getAssemblyData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getAssemblyData
#define SOAP_TYPE_PointerTo_ns1__getAssemblyData (86)
#endif

/* _ns1__staffCheck * has binding name 'PointerTo_ns1__staffCheck' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__staffCheck
#define SOAP_TYPE_PointerTo_ns1__staffCheck (82)
#endif

/* _ns1__SnSaveTechProcess_USCOREA * has binding name 'PointerTo_ns1__SnSaveTechProcess_USCOREA' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess_USCOREA
#define SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess_USCOREA (78)
#endif

/* _ns1__checkSNPangusOrderNo * has binding name 'PointerTo_ns1__checkSNPangusOrderNo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkSNPangusOrderNo
#define SOAP_TYPE_PointerTo_ns1__checkSNPangusOrderNo (74)
#endif

/* _ns1__checkSNOrderNo * has binding name 'PointerTo_ns1__checkSNOrderNo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__checkSNOrderNo
#define SOAP_TYPE_PointerTo_ns1__checkSNOrderNo (70)
#endif

/* _ns1__loadNgPanelNo * has binding name 'PointerTo_ns1__loadNgPanelNo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__loadNgPanelNo
#define SOAP_TYPE_PointerTo_ns1__loadNgPanelNo (66)
#endif

/* _ns1__loadTimeControlData * has binding name 'PointerTo_ns1__loadTimeControlData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__loadTimeControlData
#define SOAP_TYPE_PointerTo_ns1__loadTimeControlData (62)
#endif

/* _ns1__bindAssembly * has binding name 'PointerTo_ns1__bindAssembly' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__bindAssembly
#define SOAP_TYPE_PointerTo_ns1__bindAssembly (58)
#endif

/* _ns1__SnSaveTechProcess * has binding name 'PointerTo_ns1__SnSaveTechProcess' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess
#define SOAP_TYPE_PointerTo_ns1__SnSaveTechProcess (54)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (52)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnSaveTechProcess(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnSaveTechProcess *ns1__SnSaveTechProcess, _ns1__SnSaveTechProcessResponse &ns1__SnSaveTechProcessResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__bindAssembly(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__bindAssembly *ns1__bindAssembly, _ns1__bindAssemblyResponse &ns1__bindAssemblyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__loadTimeControlData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__loadTimeControlData *ns1__loadTimeControlData, _ns1__loadTimeControlDataResponse &ns1__loadTimeControlDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__loadNgPanelNo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__loadNgPanelNo *ns1__loadNgPanelNo, _ns1__loadNgPanelNoResponse &ns1__loadNgPanelNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSNOrderNo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSNOrderNo *ns1__checkSNOrderNo, _ns1__checkSNOrderNoResponse &ns1__checkSNOrderNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkSNPangusOrderNo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkSNPangusOrderNo *ns1__checkSNPangusOrderNo, _ns1__checkSNPangusOrderNoResponse &ns1__checkSNPangusOrderNoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SnSaveTechProcess_USCOREA(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SnSaveTechProcess_USCOREA *ns1__SnSaveTechProcess_USCOREA, _ns1__SnSaveTechProcess_USCOREAResponse &ns1__SnSaveTechProcess_USCOREAResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__staffCheck(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__staffCheck *ns1__staffCheck, _ns1__staffCheckResponse &ns1__staffCheckResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getAssemblyData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getAssemblyData *ns1__getAssemblyData, _ns1__getAssemblyDataResponse &ns1__getAssemblyDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsertPRateData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsertPRateData *ns1__InsertPRateData, _ns1__InsertPRateDataResponse &ns1__InsertPRateDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__blakeTestExchangeData1(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__blakeTestExchangeData1 *ns1__blakeTestExchangeData1, _ns1__blakeTestExchangeData1Response &ns1__blakeTestExchangeData1Response);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InsertTimeControl(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InsertTimeControl *ns1__InsertTimeControl, _ns1__InsertTimeControlResponse &ns1__InsertTimeControlResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkMac(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkMac *ns1__checkMac, _ns1__checkMacResponse &ns1__checkMacResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMaintanceParm(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getMaintanceParm *ns1__getMaintanceParm, _ns1__getMaintanceParmResponse &ns1__getMaintanceParmResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__fetchSnCurrentLocation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__fetchSnCurrentLocation *ns1__fetchSnCurrentLocation, _ns1__fetchSnCurrentLocationResponse &ns1__fetchSnCurrentLocationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__goNewRouteseq(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__goNewRouteseq *ns1__goNewRouteseq, _ns1__goNewRouteseqResponse &ns1__goNewRouteseqResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__blakeTestExchangeData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__blakeTestExchangeData *ns1__blakeTestExchangeData, _ns1__blakeTestExchangeDataResponse &ns1__blakeTestExchangeDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkingSNNextRoute(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__checkingSNNextRoute *ns1__checkingSNNextRoute, _ns1__checkingSNNextRouteResponse &ns1__checkingSNNextRouteResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Ispasspostburnin(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Ispasspostburnin *ns1__Ispasspostburnin, _ns1__IspasspostburninResponse &ns1__IspasspostburninResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CheckTimeGap(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CheckTimeGap *ns1__CheckTimeGap, _ns1__CheckTimeGapResponse &ns1__CheckTimeGapResponse);

#endif

/* End of soapStub.h */
